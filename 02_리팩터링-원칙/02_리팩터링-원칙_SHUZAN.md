# 2.1 리팩토링 정의

## 리팩토링

— **(명사)** 소프트웨어 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.

— **(동사)** 소프트웨어의 겉보기 동작은 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

- 저자는 특정한 방식에 따라 코드를 정리하는 것을 리팩토링이라고 칭한다.
  ⇒ 리팩토링을 하다가 코드가 깨지는 경우는 리팩토링이라고 할 수 없다.

### 겉보기 동작 (Observable Behavior)

- 리팩토링 하기 전과 후의 코드는 똑같이 작동해야 한다.
  <BUT>
  - `함추 추출하기` 를 거치면 Call Stack이 달라져서 성능이 변할 수 있다.
  - `함수 선언 바꾸기`, `함수 옮기기` 와 같은 리팩토링을 하면 모듈의 인터페이스가 바뀐다.
  → 리팩토링 과정에서 발견된 버그는 리팩토링 후에도 남아있어야 한다.

> **리팩터링은 성능 최적화와 유사하다.**
>
> - 코드를 변경하지만 프로그램의 전반적인 기능은 유지한다.
> - 리팩토링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.
> - 프로그램 성능은 좋아질 수도 나빠질 수도 있다.
>
> ---

# 2.2 두 개의 모자

소프트웨어를 개발 할때 '**기능 추가**' 와 '**리팩터링**'은 명확히 구분되야 한다.

- **기능 추가**
  - 기존 코드를 건드리지 않고, 새 기능만 추가한다.
  - 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 진행한다.
- **리팩토링**
  - 코드 재구성에 전념한다.
  - 테스트도 새로 만들지 않는다. (놓친 테스트, 인터페이스 변경시 제외)

# 2.3 리팩토링하는 이유

### **소프트웨어 설계가 좋아진다**

- 리팩토링을 통해 내부설계(아키택처)
- 중복 코드 제거를 통해 코드가 고유한 일 수행을 보장

### **소프트웨어 이해가 쉬워진다**

- 코드의 목적이 더 잘 드러나게 하여, 본인을 포함한 개발자가 쉽게 유지보수하도록 한다.

### 버그를 쉽게 찾을 수 있다

- 리팩토링을하며 프로그램 구조가 명확해지면, 버그가 명확해진다.

### 프로그래밍 속도를 높일 수 있다

- 소프트웨어 내부 품질(모듈화의 구현 품질 등)에 따라서 새로운 기능을 추가하는 속도가 달라진다.

![프로그래밍개발속도](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/32695614-137d-4527-a709-42717459bccb/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20211123%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20211123T141347Z&X-Amz-Expires=86400&X-Amz-Signature=24cdcf622ef038be67847c68ca1a7947757a82482c9b5ae12fd782f6273af7ee&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

[bliki: DesignStaminaHypothesis](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)

# 2.4 언제 리팩토링해야 할까?

저자가 제시하는 리팩토링 녹이는 방법 — **3의 법칙**

> **3의 법칙**
>
> 1. 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게되면, 계속 한다.
> 3. 비슷한 일을 세 번째로 하게되면, 리팩토링 한다.

— (Personal Opinion) — 실제로 세번 정도 반복하기 전에 추상화하게 되면, 이 후 비슷한 일이 반복되었을 때 활용성 높은 추상화를 구현하기 어려웠음. 세번정도 비슷한 일이 발생했을 때 리팩토링을 통해 추상화하는 것이 설계에 더 도움이 될 것이라고 판단됨.

### 준비를 위한 리팩토링 : 기능 쉽게 추가하게 만들기

- 리팩토링에 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
- 현재 코드를 살피며, 구조를 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다.
- 함수를 복제해서 해당 값만 수정해도 되지만, 중복 코드가 생긴다.
- 더 심한 경우는 복제한 코드가 어디까지 있는지 일일히 찾아내야 한다.
  — 이렇게 복사해서 붙여넣는 방식으로 처리하면 나중에 변형한 버전을 만들어야 할 때 번거로울 수 있다.. 이럴 때는 리팩터링 모자를 쓰고 함수 매개변수화하기를 적용한다.
- 버그를 잡을 때도 오류를 일으키는 코드가 세곳에 복제되어 퍼져 있다면 한곳으로 합치는 것이 작업하기 편하다.
- 질의 코드에 섞인 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 줄일 수 있다. 이를 리팩토링으로 개선해놓으면 버그가 수정된 상태가 오래 지속 될 가능성을 높이는 동시에 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 있다.

### 이해를 위한 리팩토링 : 코드를 이해하기 쉽게 만들기

코드를 수정 하려면 먼저 코드를 파악해야 한다.

1. 조건부 로직의 구조가 이사하지 않은지
2. 함수 이름이 잘못 정해지지 않은지

→ 이후 수정 코드를 테스트해보며 생각이 맞았는지 확인한다.

### 쓰레기 줍기 리팩터링

간단하게 수정 가능 한 것은 즉시 고치고, 시간이 걸리는 일은 메모 후, 하던 일이 완료되면 처리한다.

⇒ 쓰레기 줍기 리팩터링 (Litter-Pickup Refactoring)

- 리팩터링은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 특징은 가진다.
  → 작업을 잘게 나누면 장기간에 거쳐서 수정하더라도 코드가 깨지지 않는다.

### 계획된 리팩터링과 수시로하는 리팩터링

- 리팩터링은 프로그래밍 과정에 자연스럽게 녹이는 것이다.
- 리팩터링은 눈앞의 문제 뿐만 아니라 앞으로 할 작업에 도움을 준다.
- 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.
- **보기 싫은 코드뿐만 아니라, 잘 작성된 코드도 리팩터링을 거쳐야한다**.
  → 기존에 적합했던 기준이 오늘 작업에는 맞지 않을 수도 있다.
  → 매개변수화하거나 개별 함수를 나누는 기준을 만들고, 상황이 변해 기준을 변경할 때 리팩토링 하도록 해야 한다.
- **수정시에는 먼저 수정하기 쉽게 정돈하고, 이후에 수정한다.**
  → 소프트웨어 개발을 끝이 있는 작업으로 보면 안된다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다. 이때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많다.

### 리팩토링 커밋방식

- 버전 관리 관점에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 견해도 존재한다.

— 리팩토링은 기능 추가화 밀접하게 엮인 경우가 많기 때문에 굳이 나누는 것은 시간 낭비 일 수도 있다.

— 또한 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워질 수도 있다.

→ 리팩토링 커밋을 분리한다고하여 무조건 좋은 것은 아님을 명심하고, 적합한 방식을 찾아야 한다.

### 오래 걸리는 리팩토링

- 라이브러리를 새것으로 교체하거나 일부 코드를 다른 팀과 공유하기 위한 컴포넌트 작업 및 의존성 작업은 리팩토링이 장기적으로 걸리기도 한다.
  → 저자는 팀 전체가 리팩터링에 매달리는 것에는 회의적인 입장이다. 리팩토링은 코드를 깨뜨리지 않는다는 장점을 활용하여 누구든지 리팩터링해야 하는 코드와 관련 작업 할 때마다 개선하는 것이 효율적이라 주장한다.
  ( 예시 ) 라이브러리 교체
  1. 라이브러리 기존 것과 새 것 모두를 포용하는 추상 인터페이스를 마련한다.
  2. 기존 코드가 이 추상 인터페이스를 호출하도록 한다.
  3. 라이브러리를 교체한다.
     ⇒ 추상화로 갈아타기(Branch By Abstraction)

### 코드 리뷰에 리팩토링 활용하기

> **코드리뷰 장점**
>
> - 경험이 많은 개발자의 노하우를 적은 개발자에게 전수 할 수 있다.
> - 대규모 소프트웨어 시스템의 다양한 측면을 많은 사람이 이해하는데 도움
> - 깔끔한 코드를 작성하는데 도움을 준다.
> - 다양한 아이디어를 수집할 수 있다.
> - 리팩토링을 하면 코드 리뷰에 도움이 된다.

- 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지부터 살펴본다.

  ⇒ 쉽다면 실제로 리팩토링한다.

  ⇒ 리팩토링하다보면, 리팩토링 없이 떠올릴 수 없던 아이디어가 떠오르기도 한다.

- 리팩터링은 코드 리뷰 결과를 더 구체적으로 도출하는 데에도 도움이 된다.
- 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것이 가장 좋다
  ⇒ 짝 프로그래밍 (Pair Programming)

### 관리자에게 리팩토링에 대해 말하기

- 관리자가 기술에 정통하고 설계 지구력 가설을 잘 이해하고 있다면 리팩터링에 대해 말하라
  → 그렇지 않다면 리팩터링한다고 말하지 말아라.
  ⇒ 개발자는 효과적인 소프트웨어를 최대한 빨리 만들 수 있어야 하며, 리팩토링은 빠른 개발을 돕는다.

### 리팩토링하지 말아야 할 때

1. 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면
2. 리팩토링하는 것보다 처음부터 새로 작성하는게 더 쉬울 때

→ 해당 조건은 저자의 의견이며, 리팩토링 필요 여부에 대해 잘 결정하려면 판단력이 필요하다.

# 2.5 리팩터링 시 고려할 문제

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는데 있지 않다.
  → 오로지 경제적인 이유로 하는 것이다.
  → 리팩터링은 개발 기간을 단축시킨다.

### 코드 소유권

리팩토링하고자 하는 함수의 코드 소유자가 다른 팀이거나 혹은 함수가 고객에게 API로 제공된 경우 쓰기 권한이 없으므로 리팩토링 시에 문제가 발생하기도 한다.

1. **기존 함수를 유지하고, 함수 본문에서 새 함수를 호출하도록 수정한다.**

- 엄격한 관리
- 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않을 수 있다.
- 기존 인터페이스는 폐기 대상으로 지정하고 남겨준다. (미래에 삭제하거나 남긴다)

⇒ 이처럼 엄격하게 코드 소유권을 관리하면 인터페이스를 관리하느라 시달리게 된다.

1. **코드 소유권을 팀에 둔다.**

- 팀내 누구든 코드를 수정 할 수 있다.
  (예시) 팀마다 브랜치를 따서 수정하고 커밋 요청하는 오픈소스 개발 모델
  — 커밋 클라이언트를 관리하는 쪽에서 승인 시 기존 함수를 삭제 할 수 있다.

⇒ 대규모 시스템 개발 시 유용하다.

### 브랜치

**기능 브랜치 방식**

— 팀원마다 코드베이스의 브랜치에 작업하다가 결과물이 어느정도 쌓이면 마스터 브런치에 통합하여 다른 팀원과 공유하는 방식.

- (장) 추가될때 마다 버전을 명확히 나눌 수 있다.
- (장) 기능에 문제가 생기면 쉽게 되돌릴 수 있다.
- (단) 독립 브랜치로 작업하는 기간이 길어질수록 결과를 마스터로 통합하기 어렵다.

> **통합** — 마스터를 개인 브랜치로 가져와서 작업한 결과를 다시 마스터에 올리는 양방향 처리
>
> **머지** — 마스터를 브랜치로 머지하는 작업, 단반향

- 풀타입 개발팀에서는 기능별 브런치 머지가 복잡해지는 리팩터링 부담이 크다.
  ⇒ 통합 주기를 짧게 잡는다.
  → 지속적 통합 CI 개발 기준으로는 모든 팀원이 하루에 최소 한번은 마스터와 통합한다.
  - 머지의 복잡도를 낮출 수 있다.
  - 이때는 마스터를 항상 건강하게 유지하고, 거대한 기능을 쪼개고, 기능을 끌 수 있는 기능 토글을 적용해야한다. (그렇지 않다면 완료되지 않은 기능이 시스템을 망칠 수 있다.)

[bliki: SelfTestingCode](https://martinfowler.com/bliki/SelfTestingCode.html)

### 테스팅

- 리팩토링의 특징은 겉보기 동작이 똑같이 유지된다는 것이다.
- 리팩토링은 단계별 변경 폭이 작아서 도중에 오류 원인이 되는 코드 범위가 넓지 않다.
  → **핵심은 오류를 재빨리 잡는 것이다.**
  ⇒ 실제로 이처럼 하려면 코드의 다양한 측면을 검사하는 test suite가 필요하다.
  즉, 자가 테스트 코드를 마련해야 한다.
  **자가테스트코드**
  - 리팩터링을 할 수 있게 해준다.
  - 새 기능 추가도 안전하게 진행되도록 도와준다.
  - 실수로 만든 버그를 빠르게 찾아서 제거 할 수 있다.

뛰어난 자동 리팩터링 기능을 제공하는 환경이라면 굳이 테스트하지 않아도 오류가 생기지 않는다고 확신할 수 있다.

### 레거시코드

대규모 레거시 시스템은 테스트 코드 없이 명료하게 리펙토링하기는 어렵다.

→ 테스트 보강해야한다.

(단, 테스트를 염두하고 설계된 시스템이 아니라면 굉장히 까다로운 작업이 된다)

'레거시 코드 활용 전략' (에이콘,2018) 참고하는 것을 추천

— 테스트를 추가할 틈새를 찾아서 시스템을 테스트하는 것

- 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 한다.
- 자주 보는 부분을 더 많이 리펙토링하면 이해하기 쉽게 개선할때 얻는 효과도 크다.

### 데이터베이스

- 커다란 변경들을 쉽게 조합하고 다룰 수 있는 마이그레이션 스크립트를 작성

  (예시)

  1. 변환을 수행하는 코드를 작성한다.
  2. 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장한다.
  3. 버전 이전시 원하는 버전 사이에 있는 마이그레이션 스크립트를 실행한다.

  → 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 스크립트로 처리한다.

  ⇒ 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.

- 프로덕션 환경에 여러 단계로 나눠서 릴리즈하는 것이 좋다,
  (예시)
  1. 새로운 데이터베이스 필드만 추가한다.
  2. 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다.
  3. 데이터 베이스를 읽는 클라리언트들을 새 필드를 사용하는 버전으로 교체한다.
  4. 예전 필드를 삭제한다.
     → 프로덕션 환경에서 문제 발생시 되돌리기 쉽다.

# 2-6 리팩터링, 아키택처, 애그니(YAGNI)

리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꾸어 놓았다.

### 유연성 매커니즘

- 범용적으로 사용될 것이라고 예측되는 함수를 시나리오 대응을 위한 매개변수로 추가한다.
- 단, 매개변수로를 추가하다보면 쓰임에 비해 함수가 복잡해진다.
  → 미리 추측하지 않고, 요구 사항을 해결하느 소프트웨어를 구축한다.
  ⇒ 아키텍처도 이에 맞춰서 리팩터링 할 수 있다.
  You aren't going to need it (YAGNI)

### YAGNI

- 간결한 설계, 점진적 설계 등으로 불린다.
- 진화형 아키텍처(evolutionary architecture) 원칙이 발전하는 계기
  — 아키텍처 관련 결정을 시간을 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 수행한다.
- 아키텍처를 전혀 고려하지 말라는 뜻이 아니고, 아키텍처와 설계를 개발 프로세스에 녹이는 또 다른 방식이다.

# 2-7 리팩터링과 소프트웨어 개발 프로세스

### XP 특징

- xp가 도입되면서 리팩터링이 도입되었다.
- **지속적 통합**, **자가테스트 코드** 특징을 가진다.
- 상호의존하는 기법들을 묶은 프로세스라는 특징을 가진다.
  (자가 테스트와 리팩토링을 묶어서 테스트 주도 개발—**TDD** 라고 한다)
- 최초의 애자일 소프트웨어 방법론 중 하나로 등장했다.

### 리팩토링의 핵심 실천법

리팩토링의 핵심 실천법은 세 가지로 구성된다.

1. **자가테스트코드**
2. **지속적 통합**
3. **리팩토링 기법**

이들은 함께 사용시 서로 강력한 상승 효과를 만든다.

- 리팩토링의 첫 번째 토대는 **자가 테스트 코드**이다**.**
  → 프로그래밍 중 발생 오류를 테스트로 자동 수행 할 수 있어야 한다.
- 팀으로 개발하면서 리팩터링하려면 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링 할 수 있어야한다.
  → **지속적 통합**을 통해 리팩터링 결과를 빠르게 공유하여 삭제될 인터페이스에 기능 추가하는 일을 방지하고, 팀내 작업 문제 발생시 즉시 알아낼 수 있다.

# 2-8 리팩터링과 성능

> **리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다.**
>
> **하지만, 성능을 튜닝하기 더 쉬워진다.**

### 성능에 대한 흥미로운 사실

- 대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.
- 코드 전체를 고르게 최적화하면 90%는 효과가 없다.
  ⇒ 시간낭비이다.
- 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아내서 성능에 큰 영향을 주는 부분만 최적화하면 적은 노력으로 큰 효과를 볼 수 있다.
  → 리팩토링과 같이 최적화 수정도 작은 단계로 나누어 진행한다.
  → 컴파일과 테스트를 거쳐 프로파일러를 재 실행하여 최적화 대상을 찾아 제거한다.

### 잘 리팩토링된 프로그램의 장점

1. **기능 추가가 빨리 끝난다.**

   → _성능에 집중 할 시간을 더 벌 수 있다_.

2. **성능을 더 세밀하게 분석 할 수 있다.**

   → _프로파일러가 지적해주는 코드 범위가 좁아진다._

   ⇒ _튜닝하기 쉬워진다._

# 2.10 리팩토링 자동화

- 현재는 에디터나 독립 도구에서 리팩터링 기능을 제공할 정도로 자동 리팩터링이 흔해졌다.
  — 리팩터링 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다.
  (찾아 바꾸기로 변경하나 하는 식이다)
  → 이 방식은 허점이 많으므로 테스트 전에는 신뢰해서는 안된다.
- 자동 리팩토링을 제대로 구현하기 위해서는 코드를 텍스트 상태가 아닌 구문트리(syntax tree)로 해석하여 다뤄야 한다.
  →그래서 뛰어난 IDE가 자동 리팩터링을 더 풍부하게 제공하는 경우가 많다
  .
- IDE는 리팩터링 뿐만아니라 코드 탐색과 린팅(linting-정적분석)을 비롯한 다양한 기능을 구현하는데 구문 트리를 활용한다.

- 정적 타입 언어라면 안전하게 구현할 수 있는 리팩터링 수가 늘어난다.
  — 자바 코드라면 정적 타입 능력을 활용하여 메서드가 속한 클래스를 정확하게 알아낼 수 있기 때문에, 변경할 메소드만 제대로 골라낼 거라고 믿을 수 있다.
- 도구에서 그 이상으로 처리해 주는 경우도 있다.
  — 변수명 변경시 주석에 쓰인 이름을 물어보거나 변경하고자 핮는 함수와 같은 코드를 찾으면 코드를 강조해 보이면서, 추출함수를 변경하도록 권하기도 한다.
  → 리팩토링시에는 손에 있은 에디터외에 IDE를 사용하는 편이 프로그래밍 효율면에서 유리하다. 저자도 <이맥스>를 애요하나 자바 프로그래밍시에는 <인텔리제이 IDEA>나 <이클립스>를 사용한다.
  → but, 완성도가 낮은 도구는 Method.invoke()처럼 자바의 리플랙션 기능을 써서 메서드 호출하는 부분을 제대로 처리하지 못한다. — 물론 완성도 높은 메이저 도구는 이러한 문제가 없다 — 그러므로 리팩토링 후에는 반드시 테스트해야 한다.
