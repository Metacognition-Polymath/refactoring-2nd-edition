# 02. 리팩터링 원칙

- 1장 : 리팩터링에 대한 감
- 2장 : 시야를 넓힘 - 리팩터링 전반에 적용되는 원칙들

## 2.1 리팩터링 정의

- 리팩터링(명사) : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
  - 1장에서 `함수 추출하기`, `조건부 로직을 다형성으로 바꾸기` 처럼 이름 붙은 리팩터링 기법들이 이 정의에 해당
- 리팩터링하다(동사) : 소프트웨어 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다

#### 리팩터링

- 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고,
- 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어 내는 일

- 개별 리팩터링은 그 자체로 아주 작을 수 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다
- 리팩터링 하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다
- 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 리팩터링한 것이 아니다

#### 재구성(restructuring) vs 리팩터링(refactoring)

- 재구성 : 코드베이스를 정리하거나 구조를 바꾸는 모든 작업(포괄적인 의미)
- 리팩터링 : 재구성 중 특수한 한 형태
  - 한 번에 바꿀 수 있는 작업을 수 많은 단계로 잘게 나눠서 작업
  - 이렇게 잘게 나누는 것이 오히려 작업을 더 빨리 처리할 수 있다
  - 단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는데 시간을 뺏기지 않기 때문

#### 리팩터링을 정의할 때 사용되는 용어들

- `겉보기 동작(observable behavior)` : 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다는 뜻
  - 완전히 똑같지는 않을 수 있음
    - `함수 추출하기`를 거치면 콜스택이 달라져서 성능이 변할 수 있기 때문
    - 그렇다 하더라도 사용자 관점에서는 달라지는 점이 없어야 함
    - `함수 선언 바꾸기` 나 `함수 옮기기` 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다
  - 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 함(단, 아무도 발견하지 못한 숨은 버그는 수정해도 괜찮음)

#### 리팩터링 vs 성능 최적화

- 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다
- 목적
  - 리팩터링 : 코드를 이해하고 수정하기 쉽게 만드는 것
    - 성능은 좋아질 수도, 나빠질 수도 있다
  - 성능 최적화 : 오로지 속도 개선에만 신경을 쓴다
    - 목표 성능에 반드시 도달해야 한다면 코드는 다루기 더 어렵게 바뀔 수도 있음을 각오해야 한다

## 2.2 두 개의 모자

#### 소프트웨어 개발 목적 - 두 개의 모자

- 기능추가
  - 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다
  - 진척도는 테스트를 추가해서 통과하는지 확인
- 리팩터링

  - 기능 추가는 절대 하지 않고 오로지 코드 재구성에만 전념
  - (앞 과정에서 놓친 테스트 케이스를 발견하지 않는 한)테스트도 새로 만들지 않는다
  - 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정

- 소프트웨어를 개발 하는 동안 두 모자를 자주 바꿔쓴다
  - 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데
  - 그러면 잠시 모자를 바꿔쓰고 리팩터링한다
    - 리팩터링을 고려해서 일정을 잡아야 할 것 같다
  - 코드 구조가 어느 정도 개선 되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다
  - 추가한 기능이 제대로 작동하는지 확인했다면 작성한 코드를 살펴본다
  - 코드가 어렵게 짜였다면 다시 모자를 바꿔 쓰고 리팩터링한다
  - 전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다

## 2.3 리팩터링하는 이유

- 코드를 건강한 상태로 유지하는데 도움

### 리팩터링하면 소프트웨어 설계가 좋아진다

- 리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다
- 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다
- 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다
- `중복 코드 제거`, 코드량이 줄면 수정하는데 드는 노력은 크게 달라진다 - 바람직한 설계의 핵심

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

- 프로그래밍은 내가 원하는 바를 정확히 표현하는 일이다
- 내 소스 코드를 다른 누군가 수정하고자 읽게 될 수 있다
  - 한 시간에 끝낼 수정을 일주일이나 걸릴 수도 있다
  - 그 다른 사람이 바로 나 자신일 때가 많다
- 코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다
- 리팩터링은 코드가 더 잘 읽히게 도와준다

### 리팩터링하면 버그를 쉽게 찾을 수 있다

- 리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다
- 프로그램의 구조를 명확하게 다듬으면, '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데,
- 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다
- 리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

- 지금까지 제시한 장점을 한 마디로 정리 : 리팩터링하면 코드 개발 속도를 높일 수 있다
- 코드 품질을 높이는 데 동의하지만 전체 개발속도가 떨어질까봐 걱정할 수도 있다
- 한 시스템을 오래 개발 중인 개발자들 : 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는 데 훨씬 오래 걸린다는 말을 많이 한다
- 처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 목표를 달성하려면 리팩터링이 반드시 필요하다

## 2.4 언제 리팩터링해야 할까?

- 마틴파울러(저자)는 한 시간 간격으로 리팩터링을 한다고 한다
- 작업 흐름에 리팩터링을 녹이는 방법들에 대해 알아보자

### 3의 법칙

1. 처음에는 그냥 한다
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다

- 스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)

### 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기

- 리팩터링을 하기 가장 좋은 시점 : 코드베이스에 기능을 새로 추가하기 직전
  - 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다
- e.g., 함수내 일부 리터럴을 매개변수화 하기
  - 리터럴 : https://velog.io/@gth1123/%EB%A6%AC%ED%84%B0%EB%9F%B4literal-vs-%EC%83%81%EC%88%98constant
- 버그를 잡을 때도 마찬가지다
  - 오류를 일으키는 코드가 세 곳에 복제되어 있다면, 먼저 한 곳으로 합치는 편이 작업하기에 훨씬 편하다

### \*갑자기 생각해본 React에서 리팩터링

- 컴포넌트 분리
- custom hook 만들기

### 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기

- 코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다
- 저자는 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다
- 조건부 로직이 이상하진 않은지, 함수이름, 변수이름, 함수를 잘게 나누기 등
- 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다
- 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다
- 리팩터링 -> 복잡한 코드 아래 숨어있는 다양한 기회를 발견할 수 있음

### 쓰레기 줍기 리팩터링

- 코드 파악 중 로직이 쓸데없이 복잡한 경우
  - 간단히 수정할 수 있는 것은 즉시 고치고
  - 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리

### 계획된 리팩터링과 수시로 하는 리팩터링

#### 수시로 하는 리팩터링

- 리팩터링을 위한 일정을 따로 잡지 않고
- 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다
- 프로그래밍 과정에 자연스럽게 녹인다
- **보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수 많은 리팩터링을 거쳐야 한다**

- 보기 싫은 코드를 보면 리팩터링해야 함은 당연하지만,
- 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
- **무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 다음 쉽게 수정하자**

- 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가장 빠르게 추가하는 길인 것을 안다
- 소프트웨어 개발을 끝이 있는 작업으로 보면 안된다
- 새 기능이 필요할 때 마다 소프트웨어는 이를 반영하기 위해 수정된다
- 이때 새로 작성해 넣는 코드보다 기존 코드의 수정량이 큰 경우가 대체로 많다

#### 계획된 리팩터링

- 계획된 리팩터링이 나쁘다는 말은 아니다
- 그동안 리팩터링에 소홀했다면, 따로 시간을내서 새 기능을 추가하기 쉽도록 코드 베이스를 개선할 필요가 있다
- 이때 리팩터링에 투자한 일주일의 효과를 다음 몇 달 동안 누릴 수도 있다
- 하지만 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다

#### 프로그래밍 과정에 자연스럽게 녹인다

- 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다

### 오래걸리는 리팩터링

- 리팩터링은 대부분 몇 분 안에 끝난다
- 길어야 몇 시간 정도다
- 하지만 팀 전체가 달려들어도 몇 주 걸리는 대규모 리팩터링도 있다
  - 라이브러리를 새 것으로 교체
    - 기존 것과 새 것 모두를 포용하는 추상 인터페이스 부터 마련(추상화로 갈아타기)
  - 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼는 작업
  - 그 동안 작업하면서 쌓여온 골치 아픈 의존성을 정리
- 이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 데는 회의적이다
- 그 보다는 주어진 문제를 몇주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다
- 단계적으로 조금씩 개선

### 코드 리뷰에 리팩터링 활용하기

- 코드리뷰를 정기적으로 수행하는 조직도 있다
- 코드리뷰는 개발팀 전체에 지식을 전파하는 데 좋다
- 내 눈에는 명확한 코드가 다른 팀원에게는 그렇지 않을 수 있다
  - https://velog.io/@gth1123/Javascript-and-or
- 코드리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다

#### 리팩터링은 다른이의 코드를 리뷰하는 데도 도움된다

- 리팩터링 활용 전 : 코드를 읽고 그럭저럭 이해한 뒤, 몇 가지 개선 사항을 제시
- 리팩터링 활용 후 : 리팩터링하여 쉽게 구현할 수 있는지 살펴봄
  - 쉽다면 실제로 리팩터링을 함
  - 그러다보면 리팩터링하지 않고는 절대 떠올릴 수 없던 한 차원 높은 아이디어가 떠오르기도 한다
- 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움이 됨
  - 개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있음
  - 코드리뷰의 성취감도 훨씬 커짐
- 코드리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다
- 흔히 쓰는 Pull Request 모델(코드 작성자 없이 검토하는 방식)에서는 그리 효과적이지 않다
- 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로,
- 이왕이면 참석자가 첨석하는 방식이 좋다
- 저자가 경험한 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링하는 것
  - 짝 프로그래밍(pair programming)
  - 프로그래밍 안에 지속적인 코드리뷰가 녹아 있음

### 관리자에겐 뭐라고 말해야 할까?

- 리팩터링이 가치 있는 기능을 만들어 내지 못하는 작업이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있었다
- 리팩터링만을 위한 일정을 몇 주씩 잡는 개발팀을 보면 오해는 더욱 커진다

- 리팩터링에 대해 부정적인 관리자와 고객과 일한다면 "리팩터링한다고 말하지 말라"
- 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것
- 리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다
- 새 함수를 추가하려는데 현재 설계가 적합하지 않다면 먼저 리팩터링하고 나서 함수를 추가하는 편이 빠르다
- 버그 수정도 마찬가지다
- 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다
- 그리고 구체적인 방법은 개발자가 판단해야 한다
- 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다
  - 리팩터링이 몸에 익숙해져야 더 빨라질 것 같다
  - 익숙해지면 기존보다 빨라진다는 믿음을 갖고 리팩터링에 대한 연습을 꾸준히 해야 될 것 같다

### 리팩터링하지 말아야 할 때

- 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링 하지 않는다
- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다
  - 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다
  - 직접 해보기 전엔 어느 쪽이 쉬운지 확실히 알 수 없을 때도 많기 때문에 이런 결정을 내리긴 쉽지 않다
  - 뛰어난 판단력과 경험이 뒷받침 되어야만 이런 결정을 내릴 수 있다

## 2.5 리팩터링 시 고려할 문제

- 무언가를 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다

### 새 기능 개발 속도 저하

- 리팩터링 때문에 새 기능을 개발하는 속도가 느려진다고 여기지만, 리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다
- **리팩터링의 궁극적인 목적인 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것**

- 그렇더라도 상황에 맞게 조율해야 한다
- 예컨대 (대대적인) 리팩터링이 필요해 보이지만, 추가하려는 새 기능이 아주 작아서 기능 추가부터 하고 싶은 상황에 마주칠 수 있다
  - 이럴 땐 프로 개발자로서 가진 경험을 잘 발휘해서 결정한다
- 리팩터링을 하면 변경을 훨씬 쉽게 할 수 있다고 확신한다
- 그래서 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다

#### 반면 - 리팩터링을 하지 않는 경우

- 내가 직접 건드릴 일이 거의 없거나, 불편한 정도가 그리 심하지 않다고 판단되면 리팩터링하지 않는 편이다
- 때로는 어떻게 개선해야 할지 확실히 떠오르지 않아서 리팩터링을 미루기도 한다
  - 개선점이 떠오르면 시험 삼아 고쳐보고 더 나아지는지 살펴본다
- 가장 위험한 오류
  - 리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관' 처럼 도덕적인 이유로 정당화하는 것
- 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있지 않다
  - 오로지 경제적인 이유로 하는 것이다

#### 코드베이스가 건장하면 새 기능을 더 빨리 추가할 수 있다

### 코드 소유권

- 리팩터링을 하다보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다
- 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다
- 클라이언트에 영향을 주지 않고 원하는 형태로 변경할 수 없기 때문
- 기존함수도 그대로 유지하되 기존함수 본문에서 새 함수를 호출하도록 수정
  - 인터페이스는 복잡해지지만, 클라이언트에 영향을 주지 않기 위해선 어쩔 수 없음(deprecated으로 지정 후 남겨둘 때)
- 코드 소유권을 팀에 두는 것 : 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 함

### 브랜치

- 독립된 브랜치로 작업하는 기간이 길어질 수록 작업 결과를 마스터로 통합하기가 어려워짐
- 지속적 통합(CI : Continuos Integration) 또는 트렁크 기반 개발(TBD : Trunk-Based Development)
  - 최소 하루에 한번은 마스터와 통합
  - 다른 브랜치들과 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있음
- CI를 적용하기 위해서 치러야 할 대가
  - 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능토글(기능플래그)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 함
  - CI는 리팩터링과 궁합도 아주 좋음
    - 리팩터링을 하다보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 때가 많다
- 익스트림 프로그래밍(XP : eXtreme Programming) : CI + 리팩터링
- 기능별 브랜치를 마스터와 통합하는 작업을 매일 한다
- CI를 적용하는 편이 소프트웨어를 배포하는 데 훨씬 효과적

### 테스팅

- 리팩터링의 특징 : 프로그램의 겉보기 동작은 똑같이 유지
- 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다
- 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드 범위가 넓지 않다
- 리팩터링으로 인한 오류를 찾지 못하더라도 버전 관리 시스템을 이용하여 가장 최근에 정상 작동하던 상태로 되돌리면 된다
- 핵심 : 오류를 재빨리 잡는 것
- 코드의 다양한 측면을 검사하는 테스트 suite(모음)가 필요
- 리팩터링 하기 위해서는 자가 테스트 코드를 마련해야 한다
- 테스트코드는 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다
- 테스트 실패 -> 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴 볼 수 있음
- 검증된 몇 가지 리팩터링 기법만 조합해서 사용하자는 흐름도 등장
  - 테스트 커버리지가 넓지 않은 대규모 코드베이스도 효과적으로 리팩터링할 수 있음
  - 아직은 실험적인 단계
- CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD: Continuos Delivery)의 핵심이기도 하다

### 레거시 코드

- 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다
- 레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다
- 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다

- 이 문제의 정답은 당연히 테스트 보강이다
- 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다
  - 틈새 <- 리팩터링
  - 테스트 없이 진행하는 틈새를 만드는 리팩터링은 위험하지만 문제를 해결하기 위해서라면 감내해야할 위험
- 처음 부터 자가 테스트 코드를 작성해야 한다고 강조한 이유도 이런 난감한 상황에서 빠져나올 방법이 없기 때문
- 테스트를 기반으로 레거시 코드도 서로 관련된 부분끼리 나눠서 하나씩 공략
- 레거시 시스템의 규모가 크다면 자주보는 부분을 더 많이 리팩터링한다

### 데이터베이스

- 데이터베이스 설계와 데이터 베이스 리팩터링 기법은 현재 널리 적용되고 있다
- 이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고,
- 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다
  - ORM?
- 필드(열)의 이름을 변경하는 경우
  - 변환을 수행하는 코드를 간단히 작성한다음
  - 선언된 데이터 구조나 접근 루틴을 변경하느 코드와 함께 버전 관리 시스템에 저장한다
  - 데이터베이스를 다른 버전으로 이전할 때 마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행한다
  - [ ] 마이그레이션 이란?
- 다른 리팩터링과 마찬가지로 독립된 단계들로 쪼개는 것이 핵심이다
- 그래야 마이그레이션 후에도 정상 작동할 수 있다
- 데이터베이스 리팩터링은 프로덕션 환경에 여러단계로 나눠서 릴리스하는 것이 대체로 좋다는 점이 다른 리팩터링과 다르다
  - 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다
  - e.g., 필드 이름 바꾸기 - 병렬 수정(parallel change) 또는 팽창-수축(expand-contract)의 예시
    - 필드를 추가만 하고 사용하지는 않는다
    - 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다
    - 데이터를 읽는 클라이언트들은 새 필드를 사용하는 버전으로 조금씩 교체한다
    - 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면,
    - 더 이상 필요가 없어진 예전 필드를 삭제한다

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

- 리팩터링은 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿈
  - 예전 : 소프트웨어 설계와 이키텍처를 어느정도, 심지어 거의 완료
    - 이후 계속 부주의로 인한 부패
  - 리팩터링 도입 이후 : 개선 및 변경 가능, 탄탄한 테스트 필요
- 나중에 함수의 확장성을 생각해서 매개변수를 추가하는 것 : 유연성 메커니즘
  - 그러나 당초 예상과 다르게 바뀌거나 설계한 매커니즘 자체에 결험이 있는 등 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다
- 리팩터링을 활용
  - 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축
  - 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍쳐도 그에 맞게 리팩터링
  - 복잡도(매개변수를 늘리는 것)에 지장을 주지 않는 메커니즘은 마음껏 추가하지만
  - 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가
  - 매개변수를 추가해야될 시점이오면 그때 해결
- 간결한 설계, 점진적 설계, YAGNI : You aren't going to need it
  - 아키텍쳐와 설계를 개발 프로세스에 녹이는 방식
  - 리팩터링 없이는 효과를 볼 수 없음
  - 진화형 아키텍처 원칙이 발전하는 계기가 됨

## 2.7 리팩터링과 소프트웨어 개발 프로세스

- XP의 두드러진 특징 : `지속적 통합`, `자가 테스트 코드`, `리팩터링` 등 상호 의존하는 기법들을 하나로 묶은 프로세스
- 자가 테스트 코드 + 리팩터링 => 테스트 주도 개발(Test-Driven Development, TDD)
- XP -> 애자일 방법론 중 하나, 애자일의 부흥을 이끌음

#### 애자일(agile : 기민한)

- 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침 되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야한다
- 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다
- 자가 테스트 코드
- 리팩터링
- 지속적 통합
- 지속적 배포
- 어떤 접근법이든지 충분한 연습과 실력이 뒷받침 돼야 한다

## 2.8 리팩터링과 성능

#### 직관적인 설계 vs. 성능

- 성능을 무시하는 이유
  - 설계의 순수성을 우선시
  - 조만간 더 빠른 하드웨어가 나올거라는 믿음
- 리팩터링하면 느려질 수도 있지만 동시에 성능을 튜닝하기는 더 쉬워짐

#### 소프트웨어를 빠르게 작성하는 방법 세가지 중 하나

- 시간 예산 분배 방식
  - 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다
  - 컴포넌트는 할당된 자원 예산을 초과할 수 없다
  - 주어진 자원을 서로 주고 받는 메커니즘을 제공할 수 는 있다
  - 엄격한 시간 엄수를 강조
  - e.g., 심장 박동 조율기
  - 반면, 사내 정보 시스템과 같은 부류에는 맞지 않는 기법

#### 끊임없이 관심을 기울이는 것

- 아무것도 안 만드는 데도 시간이 걸린다
  - 측정해보지 않으면 의미가 없다
  - 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다
  - 거의 자신이 잘못 알고 있었음을 깨닫게 된다

#### 성능에 대한 흥미로운 사실

- 코드 전체를 고르게 최적화 한다면 그 중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다
- 코드를 다루기 쉽게 만들고 최적화를 하자

#### 프로파일러

- 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다
- 성능에 큰 영향을 주는 부분만 집중해서 최적화
- 리팩터링할 때 처럼 최적화를 위한 수정 또한 단계적으로 나눠서 진행
  - 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해봄
  - 성능이 개선되지 않았다면 수정내용을 되돌림
  - 만족하는 성능에 도달할 때 까지 최적화 대상을 찾아서 제거하는 일을 계속함
- 리팩터링이 최적화에 영향을 미치는 두가지
  - 1. 성능 튜닝에 투입할 시간을 벌 수 있다
    - 리팩터링이 잘 되어 있다면 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있다
  - 2. 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다
    - 프로파일러가 지적해주는 코드의 범위가 더 좁아지고 튜닝하기 쉬워진다
- 단기적으로 보면 리팩터링 단계에서 성능이 느려질 수 있지만
  - 최적화 단계에서 코드를 튜닝하기 훨신 쉬워지기 때문에
  - 결국 더 빠른 소프트웨어를 얻게 된다

## 2.9 리팩터링의 유래

- 용어의 정확한 유래는 찾을 수 없음
- 실력있는 프로그래머는 항상 자신의 코드를 정리하는 데 어느 정도의 시간을 할애해왔다
  - 깔끔한 코드가 수정하기 쉽고, 처음부터 깔끔하게 작성하는 경우는 거의 없다는 것을 알기 때문
- 리팩터링은 소프트웨어 개발 프로세스 전반의 핵심요소
- 스몰토크 : 기능이 풍부한 소프트웨어를 빠르게 작성할 수 있는 역동적인 환경(커뮤니티)
  - 컴파일 - 링크 - 실행 주기가 짧음 => 마지막으로 컴파일한 시점을 안다면 수정작업을 빠르게 진행할 수 있음
  - 객체 지향언어 => 인터페이스만 잘 정의해두면 내부 수정이 외부에 미치는 영향을 최소로 줄일 수 있음
  - 소프트웨어 개발 방법론 고민 끝에 XP가 탄생

## 2.10 리팩터링 자동화

- 자동리팩터링 지원하는 도구 등장
  - 인펠리제이 IDEA, 이클립스
- 자동 리팩터링은 스몰토크용 `리팩터링 브라우저`에서 최초로 등장
- 리팩터링 자동화하는 가장 어설픈 방법 : 소스 코드의 텍스트를 직접 조작하는 것
  - 하지만 리팩터링에 첫 발을 내딛는 데는 유용하다
- 자동리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리(syntax tree)로 해석해서 다뤄야 한다
- 정적 타입 언어라면 훨씬 안전하게 구현할 수 있는 리팩터링 수가 늘어난다
  - 정적 타입언어가 아닌 경우 반드시 테스트를 거쳐서 안전하게 리팩터링해야 한다

## 2.11 더 알고 싶다면

- 리팩터링 워크북 : 리팩터링을 연습할 수 있는 예제 제공
- 패턴을 활용한 리팩터링 : 디자인 패턴 책에서 가장 핵심적인 패턴을 골라 코드를 그 패턴대로 재구성하기 위한 방법을 다룸
- 리팩토링 데이터 베이스 : DB에 특화된 리팩터링 책
- 리팩토링 HTML
- 레거시 코드 활용 전략 : 테스트 커버리지가 낮은 오래된 코드베이스를 리팩터링하는 방법
- 리팩터링 루비 에디션
