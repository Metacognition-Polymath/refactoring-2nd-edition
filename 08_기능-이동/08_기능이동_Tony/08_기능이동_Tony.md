# 8. 기능이동

- 지금까지(6~7장) 프로그램 요소를 생성 혹은 제거하거나 이름을 변경하는 리팩터링

- 8장 => 다른 요소를 다른 컨텍스트(클래스나 모듈 등)로 옮기는 일

  - 함수 옮기기(8.1), 필드 옮기기(8.2)

- 옮기기는 문장 단위에서도 이뤄진다

  - 문장을 함수 안이나 바깥으로 옮길 때
    - 문장을 함수로 옮기기(8.3)
    - 문장을 호출한 곳으로 옮기기(8.4)
  - 같은 함수 안에서 옮길 때
    - 문장 슬라이드하기(8.6)
  - 한 덩어리의 문장들이 기존 함수와 같은 일을 할 때
    - 인라인 코드를 함수 호출로 바꾸기(8.5) => 중복을 제거

- 반복문 관련 리팩터링

  - 반복문 쪼개기(8.7) : 반복문이 단 하나의 일만 수행하도록 보장
  - 반복문 파이프라인으로 바꾸기(8.8) : 반복문을 완전히 없애버림

- 죽은 코드 제거하기(8.9)

## 8.1 함수 옮기기

### 8.1.1 함수 옮기기 - 개요

```js
// before
class Account {
  get overdraftCharge() {...}
}

// after - 다른 클래스로 함수를 옮김
class AccountType {
  get overdraftCharge() {...}
}
```

### 8.1.2 배경

- 좋은 소프트웨어 설계의 핵심 : 모듈성(modularity) - 모듈화가 얼마나 잘 되어 있느냐를 뜻 함

  - 모듈성 : 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력
  - 모듈성을 높이려면?
    - 서로 연관된 요소들을 함께 묶기
    - 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 함(그림 같은 것으로 정리하면 좋을 듯)
    - 이해도가 높아질수록 소프트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 됨
    - 높아진 이해를 반영 => 요소들을 이리저리 옮길 필요가 있음

- 컨텍스트

  - 모든 함수는 어떤 컨텍스트 안에 존재(전역도 있지만 대부분 특정 모듈에 속함)
  - 객체 지향 프로그래밍의 핵심 모듈화 : 컨텍스트 클래스
  - 함수를 다른 함수에 중첩시켜서 공통 컨텍스트를 만들음
  - 다른 클래스로 옮겨두면 사용하기 더 편한 메서드도 있다

- 함수를 옮길지 말지 정하기란 쉽지 않다

  - 현재 컨텐스트와 후보 컨텍스트 둘러보면 도움이 된다
  - 대상함수를 호출하는 함수들은 무엇인지
  - 대상함수가 호출하는 함수들은 또 무엇이 있는지
  - 대상 함수가 사용하는 데이터는 무엇인지를 살펴봐야 한다

- 서로 관련된 여러 함수를 묶을 때 - 새로운 컨텍스트

  - 여러 함수를 클래스로 묶기(6.9절)
  - 클래스 추출하기(7.5절)

- 함수의 최적의 장소를 정하기가 어려울 수 있으나 선택이 어려울 수록 큰 문제가 아닌 경우가 많다
  - 한 컨텍스트에 두고 작업해두고 그곳이 적합한지는 차차 깨달아갈 것이다.
  - 잘 맞지 않다고 판단되면 위치는 언제든 옮길 수 있다.

### 8.1.3 함수 옮기기 - 절차

1. 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.
   이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다.

- 호출되는 함수 중 함께 옮길 게 있다면 대체로 그 함수를 먼저 옮기는 게 낫다.
  - 얽혀 있는 함수가 여러 개라면 다른 곳에 미치는 영향이 적은 함수부터 옮기도록 하자.
- 하위 함수들의 호출자가 고수준 함수 하나뿐이면 먼저 하위 함수들을 고수준 함수에 인라인 한다음,
  고수준 함수를 옮기고, 옮긴 위치에서 개별 함수들을 다시 추출하자.

2. 선택한 함수가 다형 메서드인지 확인한다 - 다형메서드?

- 객체 지향 언어에서는 같은 메서드가 슈퍼클래스나 서브클래스에도 선언되어 있는지까지 고려해야한다.

3. 선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 새로운 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.

- 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 해당 요소들을 매개변수로 넘기거나 소스 컨텍스트 자체를 참조로 넘겨준다.
- 함수를 옮기게 되면 새로운 컨텍스트에 어울리는 새로운 이름으로 바꿔줘야할 경우가 많다.
  필요하면 바꿔준다.

4. 정적 분석을 수행한다.
5. 소스컨텍스트에서 타깃함수를 참조할 방법을 찾아 반영한다.
6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.

- 소스함수 : 원래의 함수

7. 테스트한다.
8. 소스 함수를 인라인(6.2절)할지 고민해본다.

- 소스 함수는 언제까지라도 위임 함수로 남겨둘 수 있다.
- 하지만 소스함수를 호출하는 곳에서 타깃함수를 직접 호출하는 데 무리가 없다면 중간 단계(소스 함수)는 제거하는 편이 낫다.

### 8.1.4 기능이동 - 예시

### 8.1.4 - 1. 예시 : 중첩 함수를 최상위로 옮기기

- GPS 추적 기록의 총 거리를 계산하는 함수

```js
// code
```

- 중첩함수인 calculate()를 최상위로 옮겨서 추적거리를 다른 정보와는 독립적으로 계산하고 싶은 상황

3. [선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 새로운 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.]

- 가장 먼저 할 일 : 이 함수를 최상위로 복사하는 것

```js
// code
// 최상위로 복사하면서 새로운 (임시)이름을 지어줌
```

- 복사한 함수 : 타깃 함수
- 원본 함수 : 소스 함수

1. [선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.]

- distance() 함수도 똑같이 처리할 수 있지만 calculateDistance()와 함께 옮기는 게 함리적으로 보인다.
  - distance()를 calculateDistance()안에 추가

4. 다시 한번 정적 분석
5. [소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.]

- 소스함수인 calculateDistance()의 본문을 수정하여 타깃 함수인 top_calculateDistance()를 호출하게 하자

7. [테스트한다.]

- 이 시점에서 반드시 모든 테스트를 수행하여 옮겨진 함수가 새 보금자리에 잘 정착했는지를 확인해야 한다.

8. [소스 함수를 인라인(6.2절)할지 고민해본다.]

- 테스트 후 소스함수는 제거한다
- distance와 radians()도 totalDistance() 안의 어떤 것에도 의존하지 않으니 최상위로 옮긴다.
- 아래 4함수 모두 최상위가 된다

```js
function tractSummary(points) {...}
function totalDistance(points) {...}
function distance(p1, p2) {...}
function radians(degrees) {...}
```

### 8.1.4 - 2. 예시 : 다른 클래스로 옮기기

- 이번엔 함수 옮기기 리팩터링의 다채로움을 보여주기 위한 예시
- 은행 이자 계산(bankCharge()), 초과 인출 이자 계산(overdraftCharge())이 Account 클래스에 있는데

  - 초과 인출 이자 계산(overdraftCharge())는 AccountType을 받아서 그것을 사용하도록 변경

#### 소스 컨텍스트에서 가져와야 할 데이터가 많다면?

- 이전 단계들에서 daysOverdrawn을 매개변수로 넘겼지만 만약 계좌에서 가져와야 할 데이터가 많았다면 다음과 같이 계좌 자체를 넘겼을 것이다.

```js
class Account {
  // ...
  get overdraftCharge() {
    return this.type.overdraftCharge(this); // this : class
  }
}

class AccountType {
  overdraftCharge(account) {
    // Account class를 받아서 사용
    // ...
  }
}
```

## 8.2 필드 옮기기

### 8.2.1 필드 옮기기 개요

```js
// before
class Customer {
  // ...
  get plan() {
    return this._plan;
  } // plan : Plan class
  get discount() {
    return this._discountRate;
  }
}

// after
class Customer {
  // ...
  get plan() {
    return this._plan;
  } // plan : Plan class
  get discount() {
    return this.plan.discountRate; // discountRate를 Customer에서 Plan으로 옮김
  }
}
```

### 8.2.2 필드 옮기기 - 배경

- 프로그램 : 동작 구현 코드 + 데이터 구조
- 경험, 도메인 주도 설계 같은 기술 -> 개선
- 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다.
- 데이터 구조의 결함 -> 혼란, 코드 복잡하게 함
- 한 레코드 변경하려 할 때 다른 레코드의 필드까지 변경해야만 한다면 => 필드의 위치가 잘못되었다는 신호

- 필들 옮기기 리팩터링

  - 더 큰 변경의 일환으로 수행 됨
  - 옮기려는 데이터가 쓰이는 패턴 때문에 당장 필드를 옮길 수 없는 경우
    - 패턴을 먼저 리팩터링한 다음 필드를 옮겨준다

- 레코드 대신 클래스나 객체가 와도 똑같다
  - 클래스 : 함수가 곁들여진 레코드
    - 클래스에 곁들여진 함수(메서드)들은 데이터를 이리저리 옮기는 작업을 쉽게 함
  - 캡슐화 되지 않은 날(bare)것의 레코드를 사용해도 똑같이 변경할 수는 있지만, 더 까다로울 것이다.

### 8.2.3 필드 옮기기 - 절차

1. 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다
2. 테스트한다.
3. 타깃 객체에 필드(와 접근자 메서드들)를 생성한다.
4. 정적 검사를 수행한다.
5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.

- 기존 필드나 메서드 중 타깃 객체를 넘겨주는게 있을지 모른다.
  없다면 이런 기능의 메서드를 쉽게 만들 수 있는지 살펴본다.
  간단치 않다면 타깃 객체를 저장할 새 필드를 소스 객체에 생성하자
  이는 영구적인 변경이 되겠지만, 더 넓은 맥락에서 리팩터링을 충분히 하고 나면 다시 없앨 수 있을 때도 있다.

6. 접근자들이 타깃 필드를 사용하도록 수정한다.

- 여러 소스에서 같은 타깃을 공유한다면, 먼저 세터를 수정하여 타깃 필드와 소스 필드 모두를 갱신하게 하고,
  이어서 일관성을 깨뜨리는 갱신을 검출할 수 있도록 어서션을 추가(10.6절)하자.
  모든 게 잘 마무리되었다면 접근자들이 타깃 필드를 사용하도록 수정한다.

7. 테스트한다.
8. 소스필드를 제거한다.
9. 테스트한다.

### 8.2.4 필드 옮기기 - 예시

#### 날 레코드(js object) 변경하기

- 8.2 필드 옮기기 리팩터링은 대체로 객체를 활용할 때가 더 수월하다.
  - 캡슐화 덕에 데이터 접근을 메서드로 자연스럽게 감싸주기 때문
- 반면, 여러함수가 레코드를 직접 사용하는 경우라면 이 리팩터링은 (여전히 수행할 가치는 있지만)훨씬 까다롭다.
- 이럴 때는 접근자 함수들을 만들고, 날 레코드를 읽고 쓰는 모든 함수가 접근자를 거치도록 고치면 된다.
- 옮길 필드가 불변이라면 값을 처음 설정할 때 소스와 타깃 필드를 한꺼번에 갱신하게 하고,
  읽기 함수들은 접진적으로 마이그레이션하자.
- (저자라면)가장 먼저 레코드 캡슐화(7.1절)하여 클래스로 바꾼다.(가능하다면..)
  이렇게 하면 필드 옮기기 리팩터링이 수월해진다.

### 8.2.4 - 2. 예시: 공유 객체로 이동하기

assert ? 어서션 - 10.6절

- js 자체에서 제공하는 메서드는 아님
- assert 함수의 일반적인 의미는 함수에 전달된 표현식이 false인 경우 오류를 발생시키는 것입니다.
- https://stackoverflow.com/questions/15313418/what-is-assert-in-javascript

## 8.3 문장을 함수로 옮기기
