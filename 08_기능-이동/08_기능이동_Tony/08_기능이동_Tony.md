# 8. 기능이동

- 지금까지(6~7장) 프로그램 요소를 생성 혹은 제거하거나 이름을 변경하는 리팩터링

- 8장 => 다른 요소를 다른 컨텍스트(클래스나 모듈 등)로 옮기는 일

  - 함수 옮기기(8.1), 필드 옮기기(8.2)

- 옮기기는 문장 단위에서도 이뤄진다

  - 문장을 함수 안이나 바깥으로 옮길 때
    - 문장을 함수로 옮기기(8.3)
    - 문장을 호출한 곳으로 옮기기(8.4)
  - 같은 함수 안에서 옮길 때
    - 문장 슬라이드하기(8.6)
  - 한 덩어리의 문장들이 기존 함수와 같은 일을 할 때
    - 인라인 코드를 함수 호출로 바꾸기(8.5) => 중복을 제거

- 반복문 관련 리팩터링

  - 반복문 쪼개기(8.7) : 반복문이 단 하나의 일만 수행하도록 보장
  - 반복문 파이프라인으로 바꾸기(8.8) : 반복문을 완전히 없애버림

- 죽은 코드 제거하기(8.9)

## 8.1 함수 옮기기

### 8.1.1 함수 옮기기 - 개요

```js
// before
class Account {
  get overdraftCharge() {...}
}

// after - 다른 클래스로 함수를 옮김
class AccountType {
  get overdraftCharge() {...}
}
```

### 8.1.2 배경

- 좋은 소프트웨어 설계의 핵심 : 모듈성(modularity) - 모듈화가 얼마나 잘 되어 있느냐를 뜻 함

  - 모듈성 : 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력
  - 모듈성을 높이려면?
    - 서로 연관된 요소들을 함께 묶기
    - 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 함(그림 같은 것으로 정리하면 좋을 듯)
    - 이해도가 높아질수록 소프트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 됨
    - 높아진 이해를 반영 => 요소들을 이리저리 옮길 필요가 있음

- 컨텍스트

  - 모든 함수는 어떤 컨텍스트 안에 존재(전역도 있지만 대부분 특정 모듈에 속함)
  - 객체 지향 프로그래밍의 핵심 모듈화 : 컨텍스트 클래스
  - 함수를 다른 함수에 중첩시켜서 공통 컨텍스트를 만들음
  - 다른 클래스로 옮겨두면 사용하기 더 편한 메서드도 있다

- 함수를 옮길지 말지 정하기란 쉽지 않다

  - 현재 컨텐스트와 후보 컨텍스트 둘러보면 도움이 된다
  - 대상함수를 호출하는 함수들은 무엇인지
  - 대상함수가 호출하는 함수들은 또 무엇이 있는지
  - 대상 함수가 사용하는 데이터는 무엇인지를 살펴봐야 한다

- 서로 관련된 여러 함수를 묶을 때 - 새로운 컨텍스트

  - 여러 함수를 클래스로 묶기(6.9절)
  - 클래스 추출하기(7.5절)

- 함수의 최적의 장소를 정하기가 어려울 수 있으나 선택이 어려울 수록 큰 문제가 아닌 경우가 많다
  - 한 컨텍스트에 두고 작업해두고 그곳이 적합한지는 차차 깨달아갈 것이다.
  - 잘 맞지 않다고 판단되면 위치는 언제든 옮길 수 있다.

### 8.1.3 함수 옮기기 - 절차

1. 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.
   이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다.

- 호출되는 함수 중 함께 옮길 게 있다면 대체로 그 함수를 먼저 옮기는 게 낫다.
  - 얽혀 있는 함수가 여러 개라면 다른 곳에 미치는 영향이 적은 함수부터 옮기도록 하자.
- 하위 함수들의 호출자가 고수준 함수 하나뿐이면 먼저 하위 함수들을 고수준 함수에 인라인 한다음,
  고수준 함수를 옮기고, 옮긴 위치에서 개별 함수들을 다시 추출하자.

2. 선택한 함수가 다형 메서드인지 확인한다 - 다형메서드?

- 객체 지향 언어에서는 같은 메서드가 슈퍼클래스나 서브클래스에도 선언되어 있는지까지 고려해야한다.

3. 선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 새로운 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.

- 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 해당 요소들을 매개변수로 넘기거나 소스 컨텍스트 자체를 참조로 넘겨준다.
- 함수를 옮기게 되면 새로운 컨텍스트에 어울리는 새로운 이름으로 바꿔줘야할 경우가 많다.
  필요하면 바꿔준다.

4. 정적 분석을 수행한다.
5. 소스컨텍스트에서 타깃함수를 참조할 방법을 찾아 반영한다.
6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.

- 소스함수 : 원래의 함수

7. 테스트한다.
8. 소스 함수를 인라인(6.2절)할지 고민해본다.

- 소스 함수는 언제까지라도 위임 함수로 남겨둘 수 있다.
- 하지만 소스함수를 호출하는 곳에서 타깃함수를 직접 호출하는 데 무리가 없다면 중간 단계(소스 함수)는 제거하는 편이 낫다.

### 8.1.4 기능이동 - 예시

### 8.1.4 - 1. 예시 : 중첩 함수를 최상위로 옮기기

- GPS 추적 기록의 총 거리를 계산하는 함수

```js
// code
```

- 중첩함수인 calculate()를 최상위로 옮겨서 추적거리를 다른 정보와는 독립적으로 계산하고 싶은 상황

3. [선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 새로운 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.]

- 가장 먼저 할 일 : 이 함수를 최상위로 복사하는 것

```js
// code
// 최상위로 복사하면서 새로운 (임시)이름을 지어줌
```

- 복사한 함수 : 타깃 함수
- 원본 함수 : 소스 함수

1. [선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.]

- distance() 함수도 똑같이 처리할 수 있지만 calculateDistance()와 함께 옮기는 게 함리적으로 보인다.
  - distance()를 calculateDistance()안에 추가

4. 다시 한번 정적 분석
5. [소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.]

- 소스함수인 calculateDistance()의 본문을 수정하여 타깃 함수인 top_calculateDistance()를 호출하게 하자

7. [테스트한다.]

- 이 시점에서 반드시 모든 테스트를 수행하여 옮겨진 함수가 새 보금자리에 잘 정착했는지를 확인해야 한다.

8. [소스 함수를 인라인(6.2절)할지 고민해본다.]

- 테스트 후 소스함수는 제거한다
- distance와 radians()도 totalDistance() 안의 어떤 것에도 의존하지 않으니 최상위로 옮긴다.
- 아래 4함수 모두 최상위가 된다

```js
function tractSummary(points) {...}
function totalDistance(points) {...}
function distance(p1, p2) {...}
function radians(degrees) {...}
```

### 8.1.4 - 2. 예시 : 다른 클래스로 옮기기

- 이번엔 함수 옮기기 리팩터링의 다채로움을 보여주기 위한 예시
- 은행 이자 계산(bankCharge()), 초과 인출 이자 계산(overdraftCharge())이 Account 클래스에 있는데

  - 초과 인출 이자 계산(overdraftCharge())는 AccountType을 받아서 그것을 사용하도록 변경

#### 소스 컨텍스트에서 가져와야 할 데이터가 많다면?

- 이전 단계들에서 daysOverdrawn을 매개변수로 넘겼지만 만약 계좌에서 가져와야 할 데이터가 많았다면 다음과 같이 계좌 자체를 넘겼을 것이다.

```js
class Account {
  // ...
  get overdraftCharge() {
    return this.type.overdraftCharge(this); // this : class
  }
}

class AccountType {
  overdraftCharge(account) {
    // Account class를 받아서 사용
    // ...
  }
}
```

## 8.2 필드 옮기기

### 8.2.1 필드 옮기기 개요

```js
// before
class Customer {
  // ...
  get plan() {
    return this._plan;
  } // plan : Plan class
  get discount() {
    return this._discountRate;
  }
}

// after
class Customer {
  // ...
  get plan() {
    return this._plan;
  } // plan : Plan class
  get discount() {
    return this.plan.discountRate; // discountRate를 Customer에서 Plan으로 옮김
  }
}
```

### 8.2.2 필드 옮기기 - 배경

- 프로그램 : 동작 구현 코드 + 데이터 구조
- 경험, 도메인 주도 설계 같은 기술 -> 개선
- 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다.
- 데이터 구조의 결함 -> 혼란, 코드 복잡하게 함
- 한 레코드 변경하려 할 때 다른 레코드의 필드까지 변경해야만 한다면 => 필드의 위치가 잘못되었다는 신호

- 필들 옮기기 리팩터링

  - 더 큰 변경의 일환으로 수행 됨
  - 옮기려는 데이터가 쓰이는 패턴 때문에 당장 필드를 옮길 수 없는 경우
    - 패턴을 먼저 리팩터링한 다음 필드를 옮겨준다

- 레코드 대신 클래스나 객체가 와도 똑같다
  - 클래스 : 함수가 곁들여진 레코드
    - 클래스에 곁들여진 함수(메서드)들은 데이터를 이리저리 옮기는 작업을 쉽게 함
  - 캡슐화 되지 않은 날(bare)것의 레코드를 사용해도 똑같이 변경할 수는 있지만, 더 까다로울 것이다.

### 8.2.3 필드 옮기기 - 절차

1. 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다
2. 테스트한다.
3. 타깃 객체에 필드(와 접근자 메서드들)를 생성한다.
4. 정적 검사를 수행한다.
5. 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.

- 기존 필드나 메서드 중 타깃 객체를 넘겨주는게 있을지 모른다.
  없다면 이런 기능의 메서드를 쉽게 만들 수 있는지 살펴본다.
  간단치 않다면 타깃 객체를 저장할 새 필드를 소스 객체에 생성하자
  이는 영구적인 변경이 되겠지만, 더 넓은 맥락에서 리팩터링을 충분히 하고 나면 다시 없앨 수 있을 때도 있다.

6. 접근자들이 타깃 필드를 사용하도록 수정한다.

- 여러 소스에서 같은 타깃을 공유한다면, 먼저 세터를 수정하여 타깃 필드와 소스 필드 모두를 갱신하게 하고,
  이어서 일관성을 깨뜨리는 갱신을 검출할 수 있도록 어서션을 추가(10.6절)하자.
  모든 게 잘 마무리되었다면 접근자들이 타깃 필드를 사용하도록 수정한다.

7. 테스트한다.
8. 소스필드를 제거한다.
9. 테스트한다.

### 8.2.4 필드 옮기기 - 예시

#### 날 레코드(js object) 변경하기

- 8.2 필드 옮기기 리팩터링은 대체로 객체를 활용할 때가 더 수월하다.
  - 캡슐화 덕에 데이터 접근을 메서드로 자연스럽게 감싸주기 때문
- 반면, 여러함수가 레코드를 직접 사용하는 경우라면 이 리팩터링은 (여전히 수행할 가치는 있지만)훨씬 까다롭다.
- 이럴 때는 접근자 함수들을 만들고, 날 레코드를 읽고 쓰는 모든 함수가 접근자를 거치도록 고치면 된다.
- 옮길 필드가 불변이라면 값을 처음 설정할 때 소스와 타깃 필드를 한꺼번에 갱신하게 하고,
  읽기 함수들은 접진적으로 마이그레이션하자.
- (저자라면)가장 먼저 레코드 캡슐화(7.1절)하여 클래스로 바꾼다.(가능하다면..)
  이렇게 하면 필드 옮기기 리팩터링이 수월해진다.

### 8.2.4 - 2. 예시: 공유 객체로 이동하기

assert ? 어서션 - 10.6절

- js 자체에서 제공하는 메서드는 아님
- assert 함수의 일반적인 의미는 함수에 전달된 표현식이 false인 경우 오류를 발생시키는 것입니다.
- https://stackoverflow.com/questions/15313418/what-is-assert-in-javascript

## 8.3 문장을 함수로 옮기기

### 8.3.1 문장을 함수로 옮기기 - 개요

```js
// before
result.push(`<p>제목 : ${person.photo.title}</p>`);
result.concat(photoData(person.photo));
function photoData(aPhoto) {
  return [`<p>위치 : ${aPhoto.location}</p>`];
}

// after
result.concat(photoData(person.photo));
function photoData(aPhoto) {
  return [
    `<p>제목 : ${person.photo.title}</p>`,
    `<p>위치 : ${aPhoto.location}</p>`,
  ];
}
```

### 8.3.2 문장을 함수로 옮기기 - 배경

- 중복 제거는 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나
- 특정 함수를 호출하는 코드가 나올 때 마다 그 앞이나 뒤에서 똑같은 코드가 추가로 실행되는 모습을 보면, 그 반복되는 부분을 피호출 함수로 합치는 방법을 궁리
- 나중에 이 코드의 동작을 여러 변형들로 나눠야 하는 순간이 오면 문장을 호출한 곳으로 옮기기(8.4절)를 적용하여 쉽게 다시 뽑아낼 수 있다
- 문장을 함수로 옮기려면 그 문장들이 피호출 함수의 일부라는 확신이 있어야 한다.
  - 피호출 함수와 한 몸은 아니지만 여전히 함께 호출돼야 하는 경우라면 단순히 해당 문장들과 피호출 함수를 통째로 또 하나의 함수로 추출(6.1절)한다.(절차의 5,6번만 제외하면 됨)
    - 한 몸이 아닌데 통째로 추출하게 되면 다른 곳에서 변형해서 사용해야 되는 경우는 어떻게 하는걸까?

### 8.3.3 문장을 함수로 옮기기 - 절차

1. 반복코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기(8.6)를 적용해 근처로 옮긴다.
2. 타깃함수를 호출하는 곳이 한 곳 뿐이면, 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다.
   이 경우라면 나머지 단계는 무시한다.
3. 호출자가 둘 이상이면 호출자 중 하나에서 `타깃 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께` 다른 함수로 추출한다. 추출한 함수에 기억하기 쉬운 임시 이름을 지어준다.
4. 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다.
   하나씩 수정할 때마다 테스트한다.
5. 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인한 후 원래 함수를 제거한다.
6. 새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다(함수 이름 바꾸기6.5절).

- 더 나은이 있다면 그 이름을 쓴다.

### 8.3.4 문장을 함수로 옮기기 - 예시

- 원본함수를 그대로 두고 중복코드와 함수호출부를 추출해서 묶으면 안전하게 바꿀 수 있는 것 같다.

## 8.4 문장을 호출한 곳으로 옮기기

- 반대 리팩터링 : 문장을 함수로 옮기기(8.3절)

### 8.4.1 문장을 호출한 곳으로 옮기기 - 개요

```js
// before
emitPhotoData(outStream, person.photo);

function emitPhotoData(outStream, photo) {
  outStream.write(`<p>제목 : ${photo.title}</p>\n`);
  outStream.write(`<p>위치 : ${photo.location}</p>\n`);
}

// after
emitPHotoData(outStream, person.photo);
outStream.write(`<p>위치 : ${photo.location}</p>\n`);

function emitPhotoData(outStream, photo) {
  outStream.write(`<p>제목 : ${photo.title}</p>\n`);
}
```

### 8.4.2 문장을 호출한 곳으로 옮기기 - 배경

- 함수는 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록이다.
- 그런데 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다.
- 코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직이게 된다.
  - 초기에는 응집도 높고 한 가지 일만 수행하던 함수가 어느새 둘 이상의 다른 일을 수행하게 바뀔 수 있다는 뜻\

### 8.4.3 문장을 호출한 곳으로 옮기기 - 절차

1. 호출자가 한두 개 뿐이고 피호출 함수도 간단한 단순한 상황이면, 피호출 함수의 처음(혹은 마지막)줄(들)을 잘라내어 호출자(들)로 복사해 넣는다(필요하면 적당히 수정한다). 테스트만 통과하면 이번 리팩터링은 여기서 끝
2. 더 복잡한 상황에서는, 이동하지 '않길' 원하는 모든 문장을 함수로 추출한 다음 검색하기 쉬운 임시 이름을 지어준다.

- 대상 함수가 서브클래스에서 오버라이드됐다면 오버라이드한 서브클래스들의 메서드 모두에서 동일하게,
  남길 부분을 메서드로 추출한다.
  이때 남겨질 메서드의 본문은 모든 클래스에서 똑같아야 한다.
  그런 다음 (슈퍼클래스의 메서드만 남기고) 서브클래스들의 메서드를 제거한다.

3. 원래 함수를 인라인한다.
4. 추출된 함수의 이름을 원래 함수의 이름으로 변경한다(함수 이름 바꾸기).

- 더 나은 이름이 떠오르면 그 이름을 사용하자

### 8.4.4 문장을 호출한 곳으로 옮기기 - 예시

- 함수에서 무언가를 꺼낼 때 변하지 않는 부분만을 따로 함수로 추출해서 함수로 만들고
- 하나씩 적용한 뒤, 원래 함수를 지우고 새로 추출한 함수(변하지 않는 부분만 모아놓은)의 이름을 원래 함수 이름으로 바꾸거나 더 좋은 이름으로 바꾼다.

## 8.5 인라인 코드를 함수 호출로 바꾸기

### 8.5.1 인라인 코드를 함수 호출로 바꾸기 - 개요

```js
// before
let appliesToMass = false;
for (const s of states) {
  if (s === "MA") {
    appliesToMass = true;
  }
}

// after
appliesToMass = states.includes("MA");
```

### 8.5.2 인라인 코드를 함수 호출로 바꾸기 - 배경

- 함수는 여러 동작을 하나로 묶어준다.
- 함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때문에 함수를 활용하면 코드를 이해하기가 쉬워진다.
- 이미 존재하는 함수와 똑같은 일을 하는 인라인 코드를 발견하면 보통은 해당 코드를 함수 호출로 대체하길 원할 것이다.
  - 예외가 있다면, 순전히 우연히 비슷한 코드가 만들어졌을 때
- 즉, 기존 함수의 코드를 수정하더라도 인라인 코드의 동작은 바뀌지 않아야 할 때 뿐이다.

### 8.5.3 인라인 코드를 함수 호출로 바꾸기 - 절차

1. 인라인 코드를 함수 호출로 대체한다.
2. 테스트한다.

## 8.6 문장 슬라이드 하기

### 8.6.1 문장 슬라이드 하기 - 개요

```js
// before
const pricingPlan = retrievePricingPlan();
const order = retrieveOrder();
let charge;
const chargePerUnit = pricingPlan.unit;

// after
const pricingPlan = retrievePricingPlan();
const order = retrieveOrder();
const chargePerUnit = pricingPlan.unit;
let charge;
```

### 8.6.2 문장 슬라이드 하기 - 배경

- 관련 코드들이 가까이 모여 있다면 이해하기가 더 쉽다.
  - e.g., 변수선언
    - 모든 변수를 함수 첫머리에 모아두기 vs 사용할 때 선언하기
- 다른 리팩터링(주로 함수 추출하기 6.1절)의 준비단계로 자주 행해짐

### 8.6.3 문장 슬라이드 하기 - 절차

1. 코드 조걱(문장들)을 이동할 목표 위치를 찾는다.
   코드 조각의 원래 위치와 목표 위치 사이의 코드들을 훑어보면서,
   조각을 모으고 나면 동작이 달라지는 코드가 있는지 살핀다.
   다음과 같은 간섭이 있다면 이 리팩터링을 포기한다.
   - 코드 조각에서 참조하는 요소를 선언하는 문장 앞으로 이동할 수 없다.
   - 코드 조각을 참조하는 요소의 뒤로는 이동할 수 없다.
   - 코드 조각에서 참조하는 요소를 수정하는 문장을 건너뛰어 이동할 수 없다.
   - 코드 조각이 수정하는 요소를 참조하는 요소를 건너뛰어 이동할 수 없다.
2. 코드 조각을 원래 위치에서 잘라내어 목표 위치에 붙여 넣는다.
3. 테스트한다.

- 테스트가 실패한다면 더 작게 나눠 시도해보라.
  - 이동거리를 줄이는 방법
  - 한번에 옮기는 조각의 크기를 줄이는 방법

### 8.6.4 문장 슬라이드 하기 - 예시

- 코드 조각 슬라이드 시 고려할 점
  - 1. 무엇을 슬라이드할지
    - 맥락과 관련이 깊음
  - 2. 슬라이드할 수 있는지
    - 명령-질의 분리 원칙
      - https://martinfowler.com/bliki/CommandQuerySeparation.html
      - 함수를 호출할 때 본의 아니게 발생한 외부 효과로 예상치 못한 결과가 나오는 일을 방지하는 데 기초가 되는 원칙
        - https://webactually.com/2018/02/06/%EB%AA%85%ED%99%95%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%EB%B2%95/#:~:text=%EB%AA%85%EB%A0%B9%2D%EC%A7%88%EC%9D%98%20%EB%B6%84%EB%A6%AC%20%EC%9B%90%EC%B9%99command,%EA%B8%B0%EC%B4%88%EA%B0%80%20%EB%90%98%EB%8A%94%20%EC%9B%90%EC%B9%99%EC%9D%B4%EB%8B%A4.

### 8.6.4 - 2 문장 슬라이드 하기 - 예시 : 조건문이 있을 때의 슬라이드

- `조건문 밖으로` 슬라이드 => 중복 로직 제거
- `조건문 안으로` 슬라이드 => 중복 로직 추가

## 8.7 반복문 쪼개기

### 8.7.1 반복문 쪼개기 - 개요

```js
let averageAge = 0;
let totalSalary = 0;
for (const p of people) {
  averageAge += p.age;
  totalSalary += p.salary;
}
averageAge = averageAge / people.length;

// after
let totalSalary = 0;
for (const p of people) {
  totalSalary += p.salary;
}
let averageAge = 0;
for (const p of people) {
  averageAge += p.age;
}
averageAge = averageAge / people.length;
```

### 8.7.2 반복문 쪼개기 - 배경

- 반복문 하나에서 두 가지 일 -> 두 가지 일 모두를 잘 이해해야 함
  - 나누면 하나만 이해하면 된다
- 반복문 쪼개기는 서로 다른 일들이 한 함수에서 이뤄지고 있다는 신호일 수 있다
  - `반복문 쪼개기`와 `함수 추출하기`는 연이어 수행하는 일이 잦다
- 병목으로 이어지는 경우는 매우 드물고, 오히려 더 강력한 최적화를 적용할 수 있는 길을 열어주기도 한다

### 8.7.3 반복문 쪼개기 - 절차

1. 반복문을 `복제`해 두 개로 만든다
2. 반복문이 `중복`되어 생기는 부수효과를 파악해서 `제거`한다
3. 테스트한다
4. 완료됐으면, 각 반복문을 함수로 추출할지 고민해본다

### 8.7.4 반복문 쪼개기 - 예시

## 8.8 반복문을 파이프라인으로 바꾸기

### 8.8.1 반복문을 파이프라인으로 바꾸기 - 개요

```js
// before
const names = [];
for (const i of input) {
  if (i.job === "programmer") {
    names.push(i.name);
  }
}

// after
const names = input.filter((i) => i.job === "programmer").map((i) => i.name);
```

### 8.8.2 반복문을 파이프라인으로 바꾸기 - 배경

- 예전엔 반복문을 많이 사용했지만
- 언어가 발달하면서 더 나은 구조를 제공
- 각 연산은 컬렉션을 입력받아 다른 컬렉션을 내 뱉음 => 대표적 연산 : map, filter
- 파이프라인으로 표현하면 -> 파이프라인을 따라가면서 어떻게 처리되는지 읽을 수 있음

### 8.8.3 반복문을 파이프라인으로 바꾸기 - 절차

1. 반복문에서 사용하는 컬렉션을 가리키는 변수를 하나 만든다.

- 기존 변수를 단순히 복사한 것일 수도 있다.

2. 반복문의 첫 줄부터 시작해서, 각각의 단위 행위를 적절한 컬렉션 파이프라인 연산으로 대체한다.
   이때 컬렉션 파이프라인 연산은 1. 에서 만든 반복문 컬렉션 변수에서 시작하여,
   이전 연산과 결과를 기초로 연쇄적으로 수행된다.
   하나를 대체할 때마다 테스트한다.
3. 반복문의 모든 동작을 대체했다면 반복문 자체를 지운다.

- 반복문이 결과를 누적 변수(accumulator)에 대입했다면 파이프라인의 결과를 그 누적 변수에 대입한다.

### 8.8.4 반복문을 파이프라인으로 바꾸기 - 예시

// 나중에 코드 따라치면서 이해해보기

## 8.9 죽은 코드 제거하기

- 운 나쁜 프로그래머는 죽은 코드의 동작을 이해하기 위해, 그리고 코드를 수정했는데도 기대한 결과가 나오지 않는 이유를 파악하기 위해 시간을 허비하게 된다.
- 코드가 더 이상 사용되지 않는다면 지워야 한다.
- 혹시 나중에 필요할 것 같아도 버전 관리 시스템이 있어서 괜찮다.
  - 어느 리비전에서 삭제를 했는지 커밋 메시지로 남겨놓자.
- 주석은 버전관리 시스템을 사용하고 나서부턴 필요없다.

### 절차

1. 죽은 코드를 외부에서 참조할 수 있는 경우라면(예컨대 함수 하나가 통째로 죽었을 때) 혹시라도 호출하고 있는지 확인한다.
2. 없다면 죽은 코드를 제거한다.
3. 테스트한다.
