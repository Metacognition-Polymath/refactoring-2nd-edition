# 8. 기능이동

- 지금까지(6~7장) 프로그램 요소를 생성 혹은 제거하거나 이름을 변경하는 리팩터링

- 8장 => 다른 요소를 다른 컨텍스트(클래스나 모듈 등)로 옮기는 일

  - 함수 옮기기(8.1), 필드 옮기기(8.2)

- 옮기기는 문장 단위에서도 이뤄진다

  - 문장을 함수 안이나 바깥으로 옮길 때
    - 문장을 함수로 옮기기(8.3)
    - 문장을 호출한 곳으로 옮기기(8.4)
  - 같은 함수 안에서 옮길 때
    - 문장 슬라이드하기(8.6)
  - 한 덩어리의 문장들이 기존 함수와 같은 일을 할 때
    - 인라인 코드를 함수 호출로 바꾸기(8.5) => 중복을 제거

- 반복문 관련 리팩터링

  - 반복문 쪼개기(8.7) : 반복문이 단 하나의 일만 수행하도록 보장
  - 반복문 파이프라인으로 바꾸기(8.8) : 반복문을 완전히 없애버림

- 죽은 코드 제거하기(8.9)

## 8.1 함수 옮기기

### 8.1.1 함수 옮기기 - 개요

```js
// before
class Account {
  get overdraftCharge() {...}
}

// after - 다른 클래스로 함수를 옮김
class AccountType {
  get overdraftCharge() {...}
}
```

### 8.1.2 배경

- 좋은 소프트웨어 설계의 핵심 : 모듈성(modularity) - 모듈화가 얼마나 잘 되어 있느냐를 뜻 함

  - 모듈성 : 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력
  - 모듈성을 높이려면?
    - 서로 연관된 요소들을 함께 묶기
    - 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 함(그림 같은 것으로 정리하면 좋을 듯)
    - 이해도가 높아질수록 소프트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 됨
    - 높아진 이해를 반영 => 요소들을 이리저리 옮길 필요가 있음

- 컨텍스트

  - 모든 함수는 어떤 컨텍스트 안에 존재(전역도 있지만 대부분 특정 모듈에 속함)
  - 객체 지향 프로그래밍의 핵심 모듈화 : 컨텍스트 클래스
  - 함수를 다른 함수에 중첩시켜서 공통 컨텍스트를 만들음
  - 다른 클래스로 옮겨두면 사용하기 더 편한 메서드도 있다

- 함수를 옮길지 말지 정하기란 쉽지 않다

  - 현재 컨텐스트와 후보 컨텍스트 둘러보면 도움이 된다
  - 대상함수를 호출하는 함수들은 무엇인지
  - 대상함수가 호출하는 함수들은 또 무엇이 있는지
  - 대상 함수가 사용하는 데이터는 무엇인지를 살펴봐야 한다

- 서로 관련된 여러 함수를 묶을 때 - 새로운 컨텍스트

  - 여러 함수를 클래스로 묶기(6.9절)
  - 클래스 추출하기(7.5절)

- 함수의 최적의 장소를 정하기가 어려울 수 있으나 선택이 어려울 수록 큰 문제가 아닌 경우가 많다
  - 한 컨텍스트에 두고 작업해두고 그곳이 적합한지는 차차 깨달아갈 것이다.
  - 잘 맞지 않다고 판단되면 위치는 언제든 옮길 수 있다.

### 8.1.3 함수 옮기기 - 절차

1. 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.
   이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다.

- 호출되는 함수 중 함께 옮길 게 있다면 대체로 그 함수를 먼저 옮기는 게 낫다.
  - 얽혀 있는 함수가 여러 개라면 다른 곳에 미치는 영향이 적은 함수부터 옮기도록 하자.
- 하위 함수들의 호출자가 고수준 함수 하나뿐이면 먼저 하위 함수들을 고수준 함수에 인라인 한다음,
  고수준 함수를 옮기고, 옮긴 위치에서 개별 함수들을 다시 추출하자.

2. 선택한 함수가 다형 메서드인지 확인한다 - 다형메서드?

- 객체 지향 언어에서는 같은 메서드가 슈퍼클래스나 서브클래스에도 선언되어 있는지까지 고려해야한다.

3. 선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 새로운 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.

- 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 해당 요소들을 매개변수로 넘기거나 소스 컨텍스트 자체를 참조로 넘겨준다.
- 함수를 옮기게 되면 새로운 컨텍스트에 어울리는 새로운 이름으로 바꿔줘야할 경우가 많다.
  필요하면 바꿔준다.

4. 정적 분석을 수행한다.
5. 소스컨텍스트에서 타깃함수를 참조할 방법을 찾아 반영한다.
6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.

- 소스함수 : 원래의 함수

7. 테스트한다.
8. 소스 함수를 인라인(6.2절)할지 고민해본다.

- 소스 함수는 언제까지라도 위임 함수로 남겨둘 수 있다.
- 하지만 소스함수를 호출하는 곳에서 타깃함수를 직접 호출하는 데 무리가 없다면 중간 단계(소스 함수)는 제거하는 편이 낫다.

### 8.1.4 기능이동 - 예시

### 8.1.4 - 1. 예시 : 중첩 함수를 최상위로 옮기기

- GPS 추적 기록의 총 거리를 계산하는 함수

```js
// code
```

- 중첩함수인 calculate()를 최상위로 옮겨서 추적거리를 다른 정보와는 독립적으로 계산하고 싶은 상황

3. [선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수(source function)라 하고 복사해서 새로운 함수(target function)라 한다.). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.]

- 가장 먼저 할 일 : 이 함수를 최상위로 복사하는 것

```js
// code
// 최상위로 복사하면서 새로운 (임시)이름을 지어줌
```

- 복사한 함수 : 타깃 함수
- 원본 함수 : 소스 함수

1. [선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다.]

- distance() 함수도 똑같이 처리할 수 있지만 calculateDistance()와 함께 옮기는 게 함리적으로 보인다.
  - distance()를 calculateDistance()안에 추가

4. 다시 한번 정적 분석
5. [소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.]

- 소스함수인 calculateDistance()의 본문을 수정하여 타깃 함수인 top_calculateDistance()를 호출하게 하자

7. [테스트한다.]

- 이 시점에서 반드시 모든 테스트를 수행하여 옮겨진 함수가 새 보금자리에 잘 정착했는지를 확인해야 한다.

8. [소스 함수를 인라인(6.2절)할지 고민해본다.]

- 테스트 후 소스함수는 제거한다
- distance와 radians()도 totalDistance() 안의 어떤 것에도 의존하지 않으니 최상위로 옮긴다.
- 아래 4함수 모두 최상위가 된다

```js
function tractSummary(points) {...}
function totalDistance(points) {...}
function distance(p1, p2) {...}
function radians(degrees) {...}
```

### 8.1.4 - 2. 예시 : 다른 클래스로 옮기기

- 이번엔 함수 옮기기 리팩터링의 다채로움을 보여주기 위한 예시
- 은행 이자 계산(bankCharge()), 초과 인출 이자 계산(overdraftCharge())이 Account 클래스에 있는데

  - 초과 인출 이자 계산(overdraftCharge())는 AccountType을 받아서 그것을 사용하도록 변경

- let's see
