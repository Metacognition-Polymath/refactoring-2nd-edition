`cd 06_기본적인-리팩터링/06_기본적인-리팩터링_Tony`

#### note

- 절차의 상세 내용(->)은 나중에 다시 읽으면서 정리하자

# 06. 기본적인 리팩터링

- 카탈로그의 첫 머리(6장) : 가장 기본적이고 많이 사용해서 제일 먼저 배워야 하는 리팩터링들

- 함수 추출, 변수 추출
  - 함수 추출하기(6.1절), 변수 추출하기(6.3절)
  - 함수 인라인하기(6.2절), 변수 인라인하기(6.4절)
  - 함수 선언바꾸기(6.5절)
  - 변수 이름 바꾸기(6.7절), 변수 캡슐화하기(6.6절)
  - 매개변수 객체 만들기(6.8절)
- 고수준 모듈로 묶기
  - 여러 함수를 클래스로 묶기(6.9절)
- 단계 쪼개기(6.11절) : 묶은 모듈들의 작업 처리 과정을 명확한 단계(phase)로 구분

## 6.1 함수 추출하기

### 6.1.1 함수 추출하기 - 개요

```js
// 6.1 함수 추출하기
// 전
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();

  // 세부 사항 출력 -> printDetails()로 추출
  console.log(`고객명 : ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
}

// 후
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();
  printDetails(outstanding);

  function printDetails(outstanding) {
    console.log(`고객명 : ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
  }
}
```

### 6.1.2 함수 추출하기 - 배경

- 가장 많이 사용
- 함수라고 표현했지만 객체지향의 method에도 똑같이 적용
- 코드 조각을 찾아 무슨일을 하는지 파악 -> 독립된 함수로 추출 + 목적에 맞는 이름 붙이기

- 코드를 언제 독립된 함수로 묶어야 할까 - 의견은 수없이 많음

  - 길이 기준
    - e.g., 함수 하나가 한 화면을 넘어가면 안 된다
  - 재사용성 기준
    - 두 번 이상 사용될 코드는 함수로 만들고, 한 번만 쓰이는 코드는 인라인 상태로 놔두는 것
  - **목적과 구현을 분리** : 가장 합리적인 기준
    - 코드를 보고 무슨 일을 파악하는 데 한참이 걸린다면 -> 그 부분을 추출 + '무슨 일'에 걸맞는 이름 짓기
    - 함수를 아주 짧게, 대체로 단 몇 줄만 담도록 작성하는 습관이 생김

- 최적화를 할 때는 다음 두 규칙을 따른다

  - 1. 하지마라
  - 2. (전문가 한정) 아직 하지 마라

- 긴 함수에는 그 목적을 설명하는 주석이 달려있는 경우가 많은데 추출한 함수 이름을 지을 때 그 주석을 참고하면 도움이 된다

### 6.1.3 함수 추출하기 - 절차

#### 1) 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다).

- 추출 대상 코드가 매우 간단하더라도 함수로 추출해서 더 잘 드러나는 이름을 붙일 수 있다면 추출한다
  - 이런 이름이 떠오르지 않는다면 추출하면 안 된다는 신호
- 하지만 추출 과정에서 좋은 이름이 떠오를 수도 있다. 처음부터 최선의 이름부터 짓고 시작할 필요는 없다
- 일단 함수로 추출해서 사용해보고 효과가 크지 않으면 다시 원래 상태로 인라인해도 된다(그 과정에서 조금이라도 깨달은게 있다면 시간낭비가 아니다)
- 중첩함수를 지원하는 언어를 사용한다면 추출한 함수를 원래 함수안에 중첩시킨다
  - 유효범위를 줄일 수 있음
  - 원래 함수의 바깥으로 꺼내야 할 때가 오면 언제든 함수 옮기기를 적용(8.1절)

#### 2) 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.

#### 3) 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.

#### 4) 변수를 다 처리했다면 컴파일한다

#### 5) 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).

#### 6) 테스트한다

#### 7) 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다(인라인 코드를 함수 호출로 바꾸기, 8.5절)

### 6.1.4 함수 추출하기 - 예시

#### 6.1.4.1 예시 : 유효범위를 벗어나는 변수가 없을 때

- 아주 간단한 코드에서는 함수 추출하기가 굉장히 쉽다

**추출 전**

```js
function printOwing(invoice) {
  let outstanding = 0;

  console.log('** 고객 채무 **');

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일(dueDate)을 기록한다
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);

  // 세부 사항을 출력한다
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

<details>
<summary>Clock.today</summary>

- Clock.today : Clock Wrapper - 시스템 시계를 감싸는 객체
  - https://martinfowler.com/bliki/ClockWrapper.html
  - Date.now() 처럼 시스템 시간을 알려주는 함수를 직접 호출하지 않음
    - 직접 호출하면 테스트 할 때마다 결과가 달라져서 오류 상황을 재현하기가 어렵기 때문

</details>

**추출**

- 해당 코드를 잘라내서 새 함수에 붙이고, 원래 자리에 새 함수 호출문을 넣는다

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner(); // 배너 출력 로직을 함수로 추출

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일(dueDate)을 기록한다
  const today = Clock.today;
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);

  printDetails(); // 세부 사항 출력 로직을 함수로 추출

  function printBanner() {
    // 배너 출력 - 내부 함수로 추출
    console.log('** 고객 채무 **');
  }

  function printDetail() {
    // 세부 사항 출력
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
    console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
  }
}
```

- printDetails()가 printOwing()에 중첩되도록 정의
  - printOwing()에 정의된 모든 변수에 접근 가능

#### 6.1.4.2 예시 : 지역 변수를 사용할 때

- (가장 간단한 경우) 지역변수를 사용하지만 다시 대입하지 않을 때 -> 지역변수들을 매개변수로 넘기면 됨

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice); // 마감일 설정 로직을 함수로 추출(+매개변수 넘기기)

  printDetails(invoice, outstanding); // 앞의 예와 달리 지역 변수를 매개변수로 전달

  function printBanner() {
    console.log('** 고객 채무 **');
  }

  function printDetail(invoice, outstanding) {
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
    console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
  }

  function recordDueDate(invoice) {
    const today = Clock.today;
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30);
  }
}
```

- 지역 변수가 (배열, 레코드, 객체와 같은) 데이터 구조라면 똑같이 매개변수로 넘긴 후 필드값을 수정할 수 있다.

#### 6.1.4.3 예시 : 지역 변수의 값을 변경할 때

- 지역 변수에 값을 대입하게 되면 문제가 복잡해진다
  - 지금은 임시 변수만을 취급
  - 만약 매개변수에 값을 대입하는 코드를 발견하면 그 변수를 쪼개서 임시변수를 새로 하나 만들어 그 변수에 대입하게 한다
- 대입 대상이 되는 임시 변수 두 가지
  - 변수가 추출된 코드 안에서만 사용될 때
    - 추출된 변수 안에서만 존재
      - 만약 변수가 초기화 되는 지점과 실제로 사용되는 지점이 떨어져 있다면 문장 슬라이드하기(8.6절)를 활용하여 변수 조작을 모두 한곳에 처리하도록 모아두면 편하다
    - 변수가 추출한 함수 밖에서 사용될 때
      - 변수에 대입된 새 값을 반환해야 함

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}
```

- 단계를 나눠서 진행해보자

- 선언문을 변수가 사용되는 코드 근처로 슬라이드한다.

```js
function printOwing(invoice) {
  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  let outstanding = 0; // 맨 위에 있던 선언문을 이 위치로 이동
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}
```

2. [추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣기]

- 그런 다음 추출할 부분을 새로운 함수로 복사한다.

```js
function printOwing(invoice) {
  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  let outstanding = 0; // 맨 위에 있던 선언문을 이 위치로 이동
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

function calculateOutsatanding(invoice) {
  let outstanding = 0; // 추출할 코드 복사
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  return outstanding; // 수정된 값 반환
}
```

3. [추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.]

- `outstanding`의 선언문을 추출할 코드 앞으로 옮겼기 때문에 매개변수로 전달하지 않아도 된다.
- 추출할 코드에서 값이 변경된 변수는 outstanding뿐이다. 따라서 이 값을 반환한다.

4. [변수를 다 처리했다면 컴파일한다]

- Javascript 환경은 컴파일 해도 아무런 값을 출력하지 않는다
- 따라서 이 단계에서는 더 이상 할 일이 없다

5. [원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).]

- 다음으로 넘어가서 추출한 코드의 원래 자리를 새로 뽑아낸 함수를 호출하는 문장으로 교체한다.
- 추출한 함수에서 새 값을 반환하니, 이 값을 원래 변수에 저장한다.

```js
function printOwing(invoice) {
  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  const outstanding = calculateOutsatanding(invoice); // 함수 추출완료. 추출한 함수가 반환한 값을 원래 변수에 저장한다.

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

function calculateOutsatanding(invoice) {
  let outstanding = 0; // 추출할 코드 복사
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  return outstanding; // 수정된 값 반환
}
```

#### 값을 반환할 변수가 여러 개라면?

- 추출할 코드를 다르게 재구성하는 방향으로 처리

  - 각각을 반환하는 함수를 여러개 만들거나
  - 굳이 여러 값을 반환해야 한다면 값들을 레코드로 묶어서 반환해도 되지만, 임시 변수 추출 작업을 다른 방식으로 처리하는 것이 나을 때가 많다
    - 임시 변수를 질의 함수로 바꾸거나(7.4절)
    - 변수를 쪼개기(9.1절)로 처리하면 좋다

- 함수를 제대로 추출했는지 확인하려면 원본 함수와 같은 문맥으로 추출해보면 판별할 수 있다

## 6.2 함수 인라인하기

### 6.2.1 함수 인라인하기 - 개요

```js
// before
function getRating(driver) {
  return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
  return driver.numberOfLateDeliveries > 5;
}

// after
function getRating(driver) {
  return driver.numberOfLateDeliveries > 5 ? 2 : 1;
}
```

## 6.3 변수 추출하기

## 6.4 변수 인라인하기

## 6.5 함수 선언 바꾸기

## 6.6 변수 캡슐화 하기

## 6.7 변수 이름 바꾸기

### 6.7.1 변수 이름 바꾸기 - 개요

```js
let a = height * width; // before
let area = height * width; // after
```

## 6.8 매개변수 객체 만들기

### 6.8.1 매개변수 객체 만들기 - 개요

```js
// before
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}

// after
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

## 6.9 여러 함수를 클래스로 묶기

### 6.9.1 여러 함수를 클래스로 묶기 - 개요

```js
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}

class Reading {
  base() {...}
  taxableCharge() {...}
  calculateBaseChare() {...}
}
```
