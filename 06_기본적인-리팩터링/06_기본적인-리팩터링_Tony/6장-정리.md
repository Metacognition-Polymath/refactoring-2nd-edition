`cd 06_기본적인-리팩터링/06_기본적인-리팩터링_Tony`

#### note

- 절차의 상세 내용(->)은 나중에 다시 읽으면서 정리하자

# 06. 기본적인 리팩터링

- 카탈로그의 첫 머리(6장) : 가장 기본적이고 많이 사용해서 제일 먼저 배워야 하는 리팩터링들

- 함수 추출, 변수 추출
  - 함수 추출하기(6.1절), 변수 추출하기(6.3절)
  - 함수 인라인하기(6.2절), 변수 인라인하기(6.4절)
  - 함수 선언바꾸기(6.5절)
  - 변수 이름 바꾸기(6.7절), 변수 캡슐화하기(6.6절)
  - 매개변수 객체 만들기(6.8절)
- 고수준 모듈로 묶기
  - 여러 함수를 클래스로 묶기(6.9절)
- 단계 쪼개기(6.11절) : 묶은 모듈들의 작업 처리 과정을 명확한 단계(phase)로 구분

## 6.1 함수 추출하기

### 6.1.1 함수 추출하기 - 개요

```js
// 6.1 함수 추출하기
// 전
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();

  // 세부 사항 출력 -> printDetails()로 추출
  console.log(`고객명 : ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
}

// 후
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();
  printDetails(outstanding);

  function printDetails(outstanding) {
    console.log(`고객명 : ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
  }
}
```

### 6.1.2 함수 추출하기 - 배경

- 가장 많이 사용
- 함수라고 표현했지만 객체지향의 method에도 똑같이 적용
- 코드 조각을 찾아 무슨일을 하는지 파악 -> 독립된 함수로 추출 + 목적에 맞는 이름 붙이기

- 코드를 언제 독립된 함수로 묶어야 할까 - 의견은 수없이 많음

  - 길이 기준
    - e.g., 함수 하나가 한 화면을 넘어가면 안 된다
  - 재사용성 기준
    - 두 번 이상 사용될 코드는 함수로 만들고, 한 번만 쓰이는 코드는 인라인 상태로 놔두는 것
  - **목적과 구현을 분리** : 가장 합리적인 기준
    - 코드를 보고 무슨 일을 파악하는 데 한참이 걸린다면 -> 그 부분을 추출 + '무슨 일'에 걸맞는 이름 짓기
    - 함수를 아주 짧게, 대체로 단 몇 줄만 담도록 작성하는 습관이 생김

- 최적화를 할 때는 다음 두 규칙을 따른다

  - 1. 하지마라
  - 2. (전문가 한정) 아직 하지 마라

- 긴 함수에는 그 목적을 설명하는 주석이 달려있는 경우가 많은데 추출한 함수 이름을 지을 때 그 주석을 참고하면 도움이 된다

### 6.1.3 함수 추출하기 - 절차

#### 1) 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다).

- 추출 대상 코드가 매우 간단하더라도 함수로 추출해서 더 잘 드러나는 이름을 붙일 수 있다면 추출한다
  - 이런 이름이 떠오르지 않는다면 추출하면 안 된다는 신호
- 하지만 추출 과정에서 좋은 이름이 떠오를 수도 있다. 처음부터 최선의 이름부터 짓고 시작할 필요는 없다
- 일단 함수로 추출해서 사용해보고 효과가 크지 않으면 다시 원래 상태로 인라인해도 된다(그 과정에서 조금이라도 깨달은게 있다면 시간낭비가 아니다)
- 중첩함수를 지원하는 언어를 사용한다면 추출한 함수를 원래 함수안에 중첩시킨다
  - 유효범위를 줄일 수 있음
  - 원래 함수의 바깥으로 꺼내야 할 때가 오면 언제든 함수 옮기기를 적용(8.1절)

#### 2) 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.

#### 3) 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.

#### 4) 변수를 다 처리했다면 컴파일한다

#### 5) 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).

#### 6) 테스트한다

#### 7) 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다(인라인 코드를 함수 호출로 바꾸기, 8.5절)

### 6.1.4 함수 추출하기 - 예시

#### 6.1.4.1 예시 : 유효범위를 벗어나는 변수가 없을 때

- 아주 간단한 코드에서는 함수 추출하기가 굉장히 쉽다

**추출 전**

```js
function printOwing(invoice) {
  let outstanding = 0;

  console.log("** 고객 채무 **");

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일(dueDate)을 기록한다
  const today = Clock.today;
  invoice.dueDate = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 30
  );

  // 세부 사항을 출력한다
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

<details>
<summary>Clock.today</summary>

- Clock.today : Clock Wrapper - 시스템 시계를 감싸는 객체
  - https://martinfowler.com/bliki/ClockWrapper.html
  - Date.now() 처럼 시스템 시간을 알려주는 함수를 직접 호출하지 않음
    - 직접 호출하면 테스트 할 때마다 결과가 달라져서 오류 상황을 재현하기가 어렵기 때문

</details>

**추출**

- 해당 코드를 잘라내서 새 함수에 붙이고, 원래 자리에 새 함수 호출문을 넣는다

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner(); // 배너 출력 로직을 함수로 추출

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일(dueDate)을 기록한다
  const today = Clock.today;
  invoice.dueDate = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 30
  );

  printDetails(); // 세부 사항 출력 로직을 함수로 추출

  function printBanner() {
    // 배너 출력 - 내부 함수로 추출
    console.log("** 고객 채무 **");
  }

  function printDetail() {
    // 세부 사항 출력
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
    console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
  }
}
```

- printDetails()가 printOwing()에 중첩되도록 정의
  - printOwing()에 정의된 모든 변수에 접근 가능

#### 6.1.4.2 예시 : 지역 변수를 사용할 때

- (가장 간단한 경우) 지역변수를 사용하지만 다시 대입하지 않을 때 -> 지역변수들을 매개변수로 넘기면 됨

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice); // 마감일 설정 로직을 함수로 추출(+매개변수 넘기기)

  printDetails(invoice, outstanding); // 앞의 예와 달리 지역 변수를 매개변수로 전달

  function printBanner() {
    console.log("** 고객 채무 **");
  }

  function printDetail(invoice, outstanding) {
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
    console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
  }

  function recordDueDate(invoice) {
    const today = Clock.today;
    invoice.dueDate = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate() + 30
    );
  }
}
```

- 지역 변수가 (배열, 레코드, 객체와 같은) 데이터 구조라면 똑같이 매개변수로 넘긴 후 필드값을 수정할 수 있다.

#### 6.1.4.3 예시 : 지역 변수의 값을 변경할 때

- 지역 변수에 값을 대입하게 되면 문제가 복잡해진다
  - 지금은 임시 변수만을 취급
  - 만약 매개변수에 값을 대입하는 코드를 발견하면 그 변수를 쪼개서 임시변수를 새로 하나 만들어 그 변수에 대입하게 한다
- 대입 대상이 되는 임시 변수 두 가지
  - 변수가 추출된 코드 안에서만 사용될 때
    - 추출된 변수 안에서만 존재
      - 만약 변수가 초기화 되는 지점과 실제로 사용되는 지점이 떨어져 있다면 문장 슬라이드하기(8.6절)를 활용하여 변수 조작을 모두 한곳에 처리하도록 모아두면 편하다
    - 변수가 추출한 함수 밖에서 사용될 때
      - 변수에 대입된 새 값을 반환해야 함

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}
```

- 단계를 나눠서 진행해보자

- 선언문을 변수가 사용되는 코드 근처로 슬라이드한다.

```js
function printOwing(invoice) {
  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  let outstanding = 0; // 맨 위에 있던 선언문을 이 위치로 이동
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}
```

2. [추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣기]

- 그런 다음 추출할 부분을 새로운 함수로 복사한다.

```js
function printOwing(invoice) {
  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  let outstanding = 0; // 맨 위에 있던 선언문을 이 위치로 이동
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

function calculateOutsatanding(invoice) {
  let outstanding = 0; // 추출할 코드 복사
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  return outstanding; // 수정된 값 반환
}
```

3. [추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.]

- `outstanding`의 선언문을 추출할 코드 앞으로 옮겼기 때문에 매개변수로 전달하지 않아도 된다.
- 추출할 코드에서 값이 변경된 변수는 outstanding뿐이다. 따라서 이 값을 반환한다.

4. [변수를 다 처리했다면 컴파일한다]

- Javascript 환경은 컴파일 해도 아무런 값을 출력하지 않는다
- 따라서 이 단계에서는 더 이상 할 일이 없다

5. [원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).]

- 다음으로 넘어가서 추출한 코드의 원래 자리를 새로 뽑아낸 함수를 호출하는 문장으로 교체한다.
- 추출한 함수에서 새 값을 반환하니, 이 값을 원래 변수에 저장한다.

```js
function printOwing(invoice) {
  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  const outstanding = calculateOutsatanding(invoice); // 함수 추출완료. 추출한 함수가 반환한 값을 원래 변수에 저장한다.

  recordDueDate(invoice);
  printDetails(invoice, outstanding);
}

function calculateOutsatanding(invoice) {
  let outstanding = 0; // 추출할 코드 복사
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }
  return outstanding; // 수정된 값 반환
}
```

#### 값을 반환할 변수가 여러 개라면?

- 추출할 코드를 다르게 재구성하는 방향으로 처리

  - 각각을 반환하는 함수를 여러개 만들거나
  - 굳이 여러 값을 반환해야 한다면 값들을 레코드로 묶어서 반환해도 되지만, 임시 변수 추출 작업을 다른 방식으로 처리하는 것이 나을 때가 많다
    - 임시 변수를 질의 함수로 바꾸거나(7.4절)
    - 변수를 쪼개기(9.1절)로 처리하면 좋다

- 함수를 제대로 추출했는지 확인하려면 원본 함수와 같은 문맥으로 추출해보면 판별할 수 있다

## 6.2 함수 인라인하기

### 6.2.1 함수 인라인하기 - 개요

```js
// before
function getRating(driver) {
  return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
  return driver.numberOfLateDeliveries > 5;
}

// after
function getRating(driver) {
  return driver.numberOfLateDeliveries > 5 ? 2 : 1;
}
```

## 6.3 변수 추출하기

## 6.4 변수 인라인하기

## 6.5 함수 선언 바꾸기

## 6.6 변수 캡슐화 하기

## 6.7 변수 이름 바꾸기

### 6.7.1 변수 이름 바꾸기 - 개요

```js
let a = height * width; // before
let area = height * width; // after
```

### 6.7.2 변수 이름 바꾸기 - 배경

- 명확한 프로그래밍의 핵심은 이름짓기다
- 이름의 중요성은 그 사용 범위에 영향을 많이 받는다
- 함수 호출 한번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경 써야 한다

### 6.7.3 변수 이름 바꾸기 - 절차

1. 폭넓게 쓰이는 변수라면 변수 캡슐화하기(6.6절)를 고려한다.
2. 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다
   - 다른 코드에서 참조하는 변수 -> 적용불가
     - 외부에 공개된 변수이므로
   - 변수 값이 변하지 않는다면 다른 이름으로 복제본을 만들어서 하나씩 점진적으로 변경한다.
     - 하나씩 바꿀 때마다 테스트한다
3. 테스트한다.

### 6.7.4 변수 이름 바꾸기 - 예시

#### 6.7.4.1 간단한 예시

- 가장 간단한 예 : 임시 변수나 인수 처럼 유효범위가 하나로 국한된 변수
- 조심해야될 변수 : 함수 밖에서도 참조할 수 있는 변수
  - 코드베이스 전체에서 두루 참조할 수도 있다.

```js
let tpHd = "untitled";

// 어떤 참조는 다음과 같이 변수를 읽기만 한다
result += `<h1>${tpHd}</h1>`;

// 값을 수정하는 곳도 있다고 해보자
tpHd = obj["articleTitle"];
```

1. [폭넓게 쓰이는 변수라면 변수 캡슐화하기(6.6절)를 고려한다.]

```js
result += `<h1>${title()}</h1>`;

setTitle(obj["articleTitle"]);

function title() {
  return tpHd;
} // tpHd 변수의 게터
function setTitle(arg) {
  tpHd = arg;
} // tpHd 변수의 세터
```

- 캡슐화 후에는 변수 이름을 바꿔도 된다

```js
let _title = "untitled";
function title() {
  return _title;
}
function setTitle(arg) {
  _title = arg;
}
```

2. [이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다]

- 래핑 함수들을 인라인해서 모든 호출자가 변수에 직접 접근하게 하는 방법도 있지만, 별로 내키지 않는 방식이다
- 이름을 바꾸기 위해 캡슐화부터 해야 할 정도로 널리 사용되는 변수라면 나중을 위해서라도 함수 안에 캡슐화 된 채로 두는 편이 좋다

#### 6.7.4.2 변수 이름 바꾸기 - 예시 : 상수 이름 바꾸기

2. [이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다]

- 상수(또는 클라이언트가 볼 때 상수처럼 작용하는 대상)의 이름은 캡슐화하지 않고도 복제방식으로 점진적으로 바꿀 수 있다

```js
// 복제 후 점진적으로 바꾸는 예시
const cpyNm = "애크미 구스베리";

// 원본의 이름을 바꾼 후, 원본의 원래 이름(기존 이름)과 같은 복제본을 만든다
const companyName = "애크미 구스베리";
const cpyNm = companyName;
```

- 기존 이름을 참조하는 코드들을 새 이름으로 점진적으로 바꾸고 다 바꿨다면 기존이름을 삭제한다.
  - 생각보다 좋은 방법일 것 같다 - 안전하게 바로 적용할 수 있을 것 같다

## 6.8 매개변수 객체 만들기

### 6.8.1 매개변수 객체 만들기 - 개요

```js
// before
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}

// after
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

### 6.8.1 매개변수 객체 만들기 - 개요

```js
// before
function amountInvoiced(startDate, endDate) {...}
function amountReceived(startDate, endDate) {...}
function amountOverdue(startDate, endDate) {...}

// after
function amountInvoiced(aDateRange) {...}
function amountReceived(aDateRange) {...}
function amountOverdue(aDateRange) {...}
```

### 6.8.2 매개변수 객체 만들기 - 배경

- 데이터 항목 여러 개가 이 함수에서 저 함수로 함께 몰려다니는 경우를 자준 본다
- 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해짐
- 함수가 받는 매개변수 수도 줄어 듬
- 묶인 데이터를 사용하면 사용하는 이름도 같아져서 일관성도 높여줌
- 매개변수 객체만들기의 진정한 힘 : 코드를 더 근본적으로 바꿔줌
  - 데이터 구조를 활용하는 형태로 프로그램 동작을 재구성
  - 데이터 구조에 담길 데이터에 공통으로 적용되는 동작을 추출 -> 함수 -> 클래스

### 6.8.3 매개변수 객체 만들기 - 절차

1. 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.

   - 개인적으로 클래스로 만드는 걸 선호한다.
   - 나중에 동작까지 함께 묶기 좋기 때문이다.
   - 주로 데이터 구조를 값 객체([Value Object](https://martinfowler.com/bliki/ValueObject.html))로 만든다.

2. 테스트한다.
3. 함수 선언 바꾸기(6.5절)로 새 데이터 구조를 매개변수로 추가한다.
4. 테스트 한다.
5. 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
6. 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
7. 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.

### 6.8.4 매개변수 객체 만들기 - 예시

- 온도 측정 값 배열에서 정상 작동 범위를 벗어난 것이 있는지 검사하는 코드

```js
// 온도 측정값을 표현하는 데이터
const station = {
  name: "ZB1",
  readings: [
    { temp: 47, time: "2021-12-13 21:10" },
    { temp: 53, time: "2021-12-13 21:20" },
    { temp: 58, time: "2021-12-13 21:30" },
    { temp: 53, time: "2021-12-13 21:40" },
    { temp: 51, time: "2021-12-13 21:50" },
  ],
};

// 정상 범위를 벗어난 측정값을 찾는 함수
function readingsOutsideRange(station, min, max) {
  return station.readings.filter((r) => r.temp < min || r.temp > max);
}

// 호출문
alert = readingsOutsideRage(
  station,
  operatingPlan.temperatureFloor, // 최저 온도
  operatingPlan.temperatureCeiling
); // 최고 온도
```

- operatingPlan의 데이터 두 개를 쌍으로 가져와서 전달 하고 있음
- 함수의 arg이름(min, max)와 다르게 Floor, Ceiling으로 사용되고 있음

1. [적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.]

- 먼저 묶은 데이터를 표현하는 클래스부터 선언하자

```js
class NumberRage {
  constructor(min, max) {
    this._data = { min: min, max: max };
  }
  get min() {
    return this._data.min;
  }
  get max() {
    return this._data.max;
  }
}
```

- 객체가 아닌 클래스를 사용한 이유

  - 매개변수 객체만들기 기법은 새로 생성한 객체로 동작까지 옮기는 더 큰 작업의 첫 단계로 수행될 때가 많기 때문

- 한편 값 객체(?)를 만들 가능성이 높기 때문에 setter는 만들지 않는다
  - 이 리팩터링을 할 때는 대부분 값 객체를 만들게 된다

3. [함수 선언 바꾸기(6.5절)로 새 데이터 구조를 매개변수로 추가한다.]

- 새로 만든 객체를 readingsOutsideRange()의 매개변수로 추가하도록 함수 선언을 바꾼다(6.5절)

```js
// 기존 함수에 매개변수 range만 더 추가 됨
function readingsOutsideRange(station, min, max, range) {
  return station.readings.filter((r) => r.temp < min || r.temp > max);
}
```

4. [테스트 한다.]

- 아직까지 동작은 하나도 바꾸지 않았으니 테스트는 문제없이 통과할 것이다.

5. [함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.]

- 이제 온도 범위를 개체 형태로 전달하도록 호출문을 하나씩 바꾼다.

```js
const range = new NumberRange(
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling
); // 새로 만든 매개변수 객체

alerts = readingsOutsideRange(
  station,
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling,
  range
); // 기존함수 그대로에 매개변수 객체만 추가로 전달
```

6. [기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.]

- 매개변수를 사용하는 부분을 하나씩 변경 후 테스트한다.
- 다 바꿨으면 기존 매개변수를 제거한다.

```js
// max부터 적용
function readingsOutsideRange(station, min, range) {
  return station.readings.filter((r) => r.temp < min || r.temp > range.max);
}

// min에도 적용
function readingsOutsideRange(station, range) {
  return station.readings.filter(
    (r) => r.temp < range.min || r.temp > range.max
  );
}

// 호출문에 적용
const range = new NumberRange(
  operatingPlan.temperatureFloor,
  operatingPlan.temperatureCeiling
);

alerts = readingsOutsideRange(station, range);
```

- 매개변수 객체 만들기 끝

#### 진정한 값 객체로 거듭나기

- 매개변수 그룹을 객체로 교체하는 일은 진짜 값진 작업의 준비단계일 뿐이다.
- 클래스로 만들어두면 관련 동자가들을 이 클래스로 옮길 수 있다

```js
class NumberRage {
  constructor(min, max) {
    this._data = { min: min, max: max };
  }
  get min() {
    return this._data.min;
  }
  get max() {
    return this._data.max;
  }
  contains(arg) {
    // 온도가 허용 범위 안에 있는지 검사하는 메서드를 클래스에 추가 하기 위한 첫 단계
    return arg >= this.min && arg <= this.max;
  }
}

function readingsOutsideRange(station, range) {
  return station.readings.filter((r) => !range.contains(r.temp));
}
```

## 6.9 여러 함수를 클래스로 묶기

### 6.9.1 여러 함수를 클래스로 묶기 - 개요

```js
function base(aReading) {...}
function taxableCharge(aReading) {...}
function calculateBaseCharge(aReading) {...}

class Reading {
  base() {...}
  taxableCharge() {...}
  calculateBaseChare() {...}
}
```

### 6.9.2 여러 함수를 클래스로 묶기 - 배경

- 클래스
  - 빌딩 블록
  - 데이터와 함수를 하나의 공유 환경으로 묶은 후 -> 그 중 일부를 외부에 제공
  - 객체 지향 언어의 기본
- (함수 호출 시 인수로 전달되는) 공통 데이터를 중심으로 긴밀하게 엮여 작동하는 함수 무리
  - 클래스로 묶고 싶어짐
  - 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고,
  - 각 함수에 전달되는 인수를 줄여서 객체 안에서 함수 호출을 간결하게 만들 수 있다
  - 이런 객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있음
- `여러 함수를 클래스로 묶기`는 이미 만들어진 함수들을 재구성할 때는 물론

  - 새로 만든 클래스와 관련하여 놓친 연산을 찾아서 새 클래스의 메서드로 뽑아내는데도 좋다

- 함수를 한데 묶는 또 다른 방법 : 여러 함수를 변환 함수로 묶기(6.10절)

  - 어느 방식으로 진행할지는 프로그램 문맥을 넓게 살펴보고 정해야 함

- 클래스로 묶을 때의 장점

  - 클라이언트가 객체의 핵심 데이터를 변경할 수 있음
  - 파생 개게들을 일관되게 관리할 수 있음

- 중첩 함수보다 클래스를 선호
  - 중첩함수는 테스트하기가 까다로울 수 있기 때문
  - 또한 한 울타리로 묶을 함수들 중 외부에 공개할 함수가 여러 개일 때는 클래스를 사용할 수 밖에 없다

### 6.9.3 여러 함수를 클래스로 묶기 - 절차

1. 함수들이 공유하는 공통 데이터 레코드를 캡슐화(7.1절)한다.
   - 공통 데이터가 레코드 구조로 묶여 있지 않다면 먼저 매개변수 객체 만들기(6.8절)로 데이터를 하나로 묶는 레코드를 만든다
2. 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다(함수 옮기기8.1절)

   - 공통 레코드의 멤버는 함수 호출문의 인수 목록에서 제거한다

3. 데이터를 조작하는 로직들은 함수로 추출(6.1절)해서 새 클래스로 옮긴다

### 6.9.4 여러 함수를 클래스로 묶기 - 예시

- 정부에서 차(tea)를 수돗물 처럼 제공하는 예시
  - 사람들은 매달 tea 계량기를 읽어서 측정값(reading)을 다음과 같이 기록한다

```js
reading = { customer: "ivan", quantity: 10, month: 5, year: 2021 };
```

- 이 데이터로 비슷한 연산을 수행하는 부분이 많다고 가정

```js
// 클라이언트 1 - 기본 요금계산
const aReading = acquireReading();
const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity;
```

```js
// 클라이언트 2 - 세금 부과계산(기본소비량만큼은 면세)
const aReading = acquireReading();
const base = baseRate(aReading.month, aReading.year) * aReading.quantity;
const taxableCharge = Math.max(0, base - taxThreshold(aReading.year));
// Threshold : 한계점
```

```js
// 클라이언트 3 - 함추 추출된 코드 발견
const aReading = acquireReading();
const basicChargeAmount = calculateBaseCharge(aReading);

// 기본 요금 계산 함수
function calculateBaseCharge(aReading) {
  return baseRate(aReading.month, aReading.year) * aReading.quantity;
}
```

- 이런 코드를 보면 본능적으로 앞의 두 클라이언트(클라이언트 1, 2)도 이 함수(클라이언트 3)를 사용하도록 고치려고 한다
- 하지만 이렇게 최상위 함수로 두면 못 보고 지나치기 쉽다는 문제가 있다
- 이런 함수를 데이터 처리 코드 가까이에 두는 것이 좋다 => **클래스**

1. [함수들이 공유하는 공통 데이터 레코드를 캡슐화(7.1절)한다.]

- 레코드를 클래스로 변환하기 위해 레코드를 캡슐화한다

```js
class Reading {
  constructor(data) {
    this._customer = data.customer;
    this._quantity = data.quantity;
    this._month = data.month;
    this._year = data.year;
  }
  get customer() {
    return this._customer;
  }
  get quantity() {
    return this._quantity;
  }
  get month() {
    return this._month;
  }
  get year() {
    return this._year;
  }
}
```

2. [공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다(함수 옮기기8.1절)]

- 이미 만들어져 있는 calculateBaseCharge() 부터 옮기자
- 새 클래스를 사용하려면 데이터를 얻자마자 객체로 만들어야 한다

```js
// 클라이언트 3
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const basicChargeAmount = calculateBaseCharge(aReading);
```

- 그런 다음 calculateBaseCharge()를 새로 만든 클래스로 옮긴다(함수 옮기기8.1절).

```js
class Reading {
  constructor(data) {
    this._customer = data.customer;
    this._quantity = data.quantity;
    this._month = data.month;
    this._year = data.year;
  }
  get customer() {
    return this._customer;
  }
  get quantity() {
    return this._quantity;
  }
  get month() {
    return this._month;
  }
  get year() {
    return this._year;
  }
  get calculateBaseCharge() {
    // 메서드 이름을 원하는 대로 바꿀 수 있다 => get calculateBaseCharge()
    return baseRate(this.month, this.year) * this.quantity; // baseRate은 어디있지?
  }
}

// 클라이언트 3
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const basicChargeAmount = aReading.calculateBaseCharge; // 메서드 이름을 원하는 대로 바꿀 수 있다 => aReading.baseCharge;
```

- 메서드 이름을 원하는 대로 바꾼다

- 클라이언트 1, 2에 class를 사용한다

```js
// 클라이언트 1
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const baseCharge = aReading.baseCharge;
```

```js
// 클라이언트 2
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const taxableCharge = Math.max(
  0,
  aReading.baseCharge - taxThreshold(aReading.year)
);
```

3. [데이터를 조작하는 로직들은 함수로 추출(6.1절)해서 새 클래스로 옮긴다]

- 이어서 세금을 부과할 소비량을 계산하는 코드를 함수로 추출(6.1절)한다

```js
// 클라이언트 2
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const taxableCharge = taxableChargeFn(aReading);

function taxableChargeFn(aReading) {
  return Math.max(0, aReading.baseCharge - taxThreshold(aReading.year));
}
```

- 그리고 추출한 함수를 Reading 클래스로 옮긴다(함수 옮기기 8.1절)

```js
class Reading {
  constructor(data) {
    this._customer = data.customer;
    this._quantity = data.quantity;
    this._month = data.month;
    this._year = data.year;
  }
  get customer() {
    return this._customer;
  }
  get quantity() {
    return this._quantity;
  }
  get month() {
    return this._month;
  }
  get year() {
    return this._year;
  }
  get calculateBaseCharge() {
    // 메서드 이름을 원하는 대로 바꿀 수 있다 => get calculateBaseCharge()
    return baseRate(this.month, this.year) * this.quantity; // baseRate은 어디있지?
  }

  get taxableChargeFn() {
    return Math.max(0, this.baseCharge - taxThreshold(this.year));
  }
}

// 클라이언트 2 - 책에서 클라이언트 3으로 되어있는데 2가 맞음
const rawReading = acquireReading();
const aReading = new Reading(rawReading);
const taxableCharge = aReading.taxableCharge;
```

- 프로그램의 다른 부분에서 데이터를 갱신할 가능성이 꽤 있을 때는 클래스로 묶어두면 큰 도움이 된다
