`cd 06_기본적인-리팩터링/06_기본적인-리팩터링_Tony`

#### note

- 절차의 상세 내용(->)은 나중에 다시 읽으면서 정리하자

# 06. 기본적인 리팩터링

- 카탈로그의 첫 머리(6장) : 가장 기본적이고 많이 사용해서 제일 먼저 배워야 하는 리팩터링들

- 함수 추출, 변수 추출
  - 함수 추출하기(6.1절), 변수 추출하기(6.3절)
  - 함수 인라인하기(6.2절), 변수 인라인하기(6.4절)
  - 함수 선언바꾸기(6.5절)
  - 변수 이름 바꾸기(6.7절), 변수 캡슐화하기(6.6절)
  - 매개변수 객체 만들기(6.8절)
- 고수준 모듈로 묶기
  - 여러 함수를 클래스로 묶기(6.9절)
- 단계 쪼개기(6.11절) : 묶은 모듈들의 작업 처리 과정을 명확한 단계(phase)로 구분

## 6.1 함수 추출하기

### 6.1.1 함수 추출하기 - 개요

```js
// 6.1 함수 추출하기
// 전
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();

  // 세부 사항 출력 -> printDetails()로 추출
  console.log(`고객명 : ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
}

// 후
function printOwing(invoice) {
  printBanner();
  let outstanding = calculateOutstanding();
  printDetails(outstanding);

  function printDetails(outstanding) {
    console.log(`고객명 : ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
  }
}
```

### 6.1.2 함수 추출하기 - 배경

- 가장 많이 사용
- 함수라고 표현했지만 객체지향의 method에도 똑같이 적용
- 코드 조각을 찾아 무슨일을 하는지 파악 -> 독립된 함수로 추출 + 목적에 맞는 이름 붙이기

- 코드를 언제 독립된 함수로 묶어야 할까 - 의견은 수없이 많음

  - 길이 기준
    - e.g., 함수 하나가 한 화면을 넘어가면 안 된다
  - 재사용성 기준
    - 두 번 이상 사용될 코드는 함수로 만들고, 한 번만 쓰이는 코드는 인라인 상태로 놔두는 것
  - **목적과 구현을 분리** : 가장 합리적인 기준
    - 코드를 보고 무슨 일을 파악하는 데 한참이 걸린다면 -> 그 부분을 추출 + '무슨 일'에 걸맞는 이름 짓기
    - 함수를 아주 짧게, 대체로 단 몇 줄만 담도록 작성하는 습관이 생김

- 최적화를 할 때는 다음 두 규칙을 따른다

  - 1. 하지마라
  - 2. (전문가 한정) 아직 하지 마라

- 긴 함수에는 그 목적을 설명하는 주석이 달려있는 경우가 많은데 추출한 함수 이름을 지을 때 그 주석을 참고하면 도움이 된다

### 6.1.3 함수 추출하기 - 절차

#### 1) 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다).

- 추출 대상 코드가 매우 간단하더라도 함수로 추출해서 더 잘 드러나는 이름을 붙일 수 있다면 추출한다
  - 이런 이름이 떠오르지 않는다면 추출하면 안 된다는 신호
- 하지만 추출 과정에서 좋은 이름이 떠오를 수도 있다. 처음부터 최선의 이름부터 짓고 시작할 필요는 없다
- 일단 함수로 추출해서 사용해보고 효과가 크지 않으면 다시 원래 상태로 인라인해도 된다(그 과정에서 조금이라도 깨달은게 있다면 시간낭비가 아니다)
- 중첩함수를 지원하는 언어를 사용한다면 추출한 함수를 원래 함수안에 중첩시킨다
  - 유효범위를 줄일 수 있음
  - 원래 함수의 바깥으로 꺼내야 할 때가 오면 언제든 함수 옮기기를 적용(8.1절)

#### 2) 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.

#### 3) 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.

#### 4) 변수를 다 처리했다면 컴파일한다

#### 5) 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).

#### 6) 테스트한다

#### 7) 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다(인라인 코드를 함수 호출로 바꾸기, 8.5절)

### 6.1.4 함수 추출하기 - 예시

#### 6.1.4.1 예시 : 유효범위를 벗어나는 변수가 없을 때

- 아주 간단한 코드에서는 함수 추출하기가 굉장히 쉽다

**추출 전**

```js
function printOwing(invoice) {
  let outstanding = 0;

  console.log("** 고객 채무 **");

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일(dueDate)을 기록한다
  const today = Clock.today;
  invoice.dueDate = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 30
  );

  // 세부 사항을 출력한다
  console.log(`고객명: ${invoice.customer}`);
  console.log(`채무액: ${outstanding}`);
  console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
}
```

<details>
<summary>Clock.today</summary>

- Clock.today : Clock Wrapper - 시스템 시계를 감싸는 객체
  - https://martinfowler.com/bliki/ClockWrapper.html
  - Date.now() 처럼 시스템 시간을 알려주는 함수를 직접 호출하지 않음
    - 직접 호출하면 테스트 할 때마다 결과가 달라져서 오류 상황을 재현하기가 어렵기 때문

</details>

**추출**

- 해당 코드를 잘라내서 새 함수에 붙이고, 원래 자리에 새 함수 호출문을 넣는다

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner(); // 배너 출력 로직을 함수로 추출

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  // 마감일(dueDate)을 기록한다
  const today = Clock.today;
  invoice.dueDate = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 30
  );

  printDetails(); // 세부 사항 출력 로직을 함수로 추출

  function printBanner() {
    // 배너 출력 - 내부 함수로 추출
    console.log("** 고객 채무 **");
  }

  function printDetail() {
    // 세부 사항 출력
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
    console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
  }
}
```

- printDetails()가 printOwing()에 중첩되도록 정의
  - printOwing()에 정의된 모든 변수에 접근 가능

#### 6.1.4.2 예시 : 지역 변수를 사용할 때

- (가장 간단한 경우) 지역변수를 사용하지만 다시 대입하지 않을 때 -> 지역변수들을 매개변수로 넘기면 됨

```js
function printOwing(invoice) {
  let outstanding = 0;

  printBanner();

  // 미해결 채무(outstanding)를 계산한다.
  for (const o of invoice.orders) {
    outstanding += o.amount;
  }

  recordDueDate(invoice); // 마감일 설정 로직을 함수로 추출(+매개변수 넘기기)

  printDetails(invoice, outstanding); // 앞의 예와 달리 지역 변수를 매개변수로 전달

  function printBanner() {
    console.log("** 고객 채무 **");
  }

  function printDetail(invoice, outstanding) {
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
    console.log(`마감일: ${invoice.dueDate.toLocaleDateString()}`);
  }

  function recordDueDate(invoice) {
    const today = Clock.today;
    invoice.dueDate = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate() + 30
    );
  }
}
```

- 지역 변수가 (배열, 레코드, 객체와 같은) 데이터 구조라면 똑같이 매개변수로 넘긴 후 필드값을 수정할 수 있다.

#### 6.1.4.2 예시 : 지역 변수의 값을 변경할 때

- 지역 변수에 값을 대입하게 되면 문제가 복잡해진다
