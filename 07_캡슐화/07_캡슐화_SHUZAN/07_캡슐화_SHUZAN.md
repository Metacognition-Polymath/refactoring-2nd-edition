## 들어가며

- **모듈을 분리하는 가장 중요한 기준?**

  ⇒ 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있다.

  - 대표적인 방법
    1. 레코드 캡슐화하기
    2. 컬렉션 캡슐화하기

- **클래스는 본래 정보를 숨기는 용도로 설계 되었다.**

  - 여러 함수를 클래스에 묶기(6.9장)
  - 클래스 추출하기(7.5장)
  - 클래스 인라인하기(7.6장)

- **클래스는 연결 관계를 숨기는 데도 유용하다**

  - 위임 숨기기(7.7장)
    → 하지만, 너무 많이 숨기면 인터페이스가 비대해진다.
    ⇒ 중개자 제거하기(7.8장)을 이용할 수 있다.

- **가장 큰 캡슐화 단위는 클래스와 모듈이지만 함수도 구현을 캡슐화 한다.**
  → 알고리즘을 통째로 바꿔야 할 떄가 있는데, 함수 추출하기(6.1장)로 알고리즘 전체를 함수 하나에 담은 뒤 알고리즘 교체하기(7.9장) 에 적용하면 된다.

## 7.1장 레코드 캡슐화하기

대부분의 프로그래밍 언어는 데이터 레코드는 표현하는 구조를 제공한다.

→ 직관적인 방식으로 묶으면 각각을 취급할 때보다 의미있는 단위로 전달한다.

**단순한 레코드의 단점**

→ 값을 명확히 구분해야 하는 점이 번거롭다.

⇒ 객체를 사용하면 어떻게 저장했는지 숨긴 채 각 메서드로 제공가능하다.

**레코드 두가지 구조**

1. 필드 이름을 노출하는 형태
2. 원하는 이름을 쓸 수 있는 형태

   → 주로 라이브러리에서 해쉬, 맵, 해쉬맵, 딕셔너리, 연관 배열로 제공한다.

- 코드를 작성하나보면 중첩된 리스트나 해쉬맵을 받아서 JSON이나 XML 포멧으로 직렬화 할 떄가 많다.
  ⇒ 이런 구조 역시 캡슐화 할 수 있다.
  ⇒ 데이터 수정이 쉬워진다.

> **절차**
>
> 1. 레코드를 담은 변수를 캡슐화 한다.
>
>    → 레코드를 캡슐화하는 함수 이름을 검색하기 쉽게 지어준다.
>
> 2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다.
> 3. 테스트한다.
> 4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
> 5. 레코드를 반호나하는 예전 함수를 사용하는 코드를 새 함수를 사용하도록 바꾼다.
> 6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
> 7. 테스트한다.
> 8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐하기를 재귀적으로 적용한다.

## 7.2 컬렉션 캡슐화하기

**가변데이터 캡슐화 장점**

- 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉽다.
- 필요한 시점에 데이터 구조를 변경하기 쉽다.

**클래스 컬렉션**

— 유의할 점 : 컬렉션 변수 접근을 캡슐화하면서 게터가 컬렉션을 반환하면, 컬렉션 원소가 바뀐다.

- **변경방식 -** 컬렉션을 감싼 클랙스에 add() , remove() 와 같은 컬렉션 변경자 메서드를 만든다.
- 컬렉션 게터가 원본 컬렉션을 반환하지 않도록 만들어서 실수 방지
  - 컬렉션을 읽기 전용으로만 사용한다.
    → 이터레이터나 열거형 객체 기반 라이브러리도 유사한 방법을 사용한다.
    → 컬렉션 게터를 제공하되 내부 컬렉션 복제본을 반환하도록 한다.

> **절차**
>
> 1. 컬렉션을 캡슐화한다
> 2. 원소를 추가/ 제거하는 함수를 추가한다.
>    1. 컬렉션 자체는 통쨰로 바꾸는 세터를 제거한다.
> 3. 정적 검사를 수행한다.
> 4. 컬렉션 참조하는 부분을 모두 찾아서 바꾼다.
> 5. 원본 내용을 수정할 수 없는 읽기 전용 프락시나 복제본을 반환한다.
> 6. 테스트한다.

## 7.3 기본형을 객체로 바꾸기

개발 초기에느 단순한 정보나 숫자를 간단한 데이터로 표현한다.

개발이 진행되면서 출력이상이 필요하면 전용 클래스로 변환하면, 유용한 도구가 된다

> **절차**
>
> 1. 캡슐화한다.
> 2. 값 클래스를 만든다.
> 3. 정적 검사를 수행한다.
> 4. 인스턴스를 만들어서 필드 저장하는 세터를 수정한다.
> 5. 클래스 게터 호출 결과를 반환하도록 게터를 수정한다.
> 6. 테스트
> 7. 이름 바꿀때 접근자 동작을 더 잘 들러내는지 검토한다.

## 7.4 임시 변수를 질의 함수로 바꾸기

**임시 변수 사용**

- 값을 계산하는 코드가 반복되는 것을 줄인다.
- 값의 의미를 설명 할 수도 있어서 유용하다.

**긴 함수**

- 한 부분을 별도 함수로 추출시
  - 변수들을 각각의 함수로 만들면 수월하다.
  - 함수에 변수를 따로 전달 할 필요가 없다
    → 추출함수와 원래 함수 경계가 분명해진다.
    ⇒ 부자연스러운 의존관계나 부수 효과를 찾아 제거하는데 유용하다.

**변수 대신 함수로 만들기**

- 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있다.
- 코드 중복이 줄어든다.

**임시 변수를 질의함수로 바꾸기**는 클래스 안에서 적용할떄 효과가 가장 크다

- 클래스를 추출할 메서드들에 공유 컨텍스트를 제공하기 때문이다.
- 클래스 밖에 최상위 함수로 추출하면 매개변수가 너무 많아서 함수를 사용하는 장점이 줄어든다.
- 중첩함수를 사용하면 로직을 널리 공유하는데 한계가 있다.
  → 변수는 값을 한 번만 계산하고, 그 뒤로는 읽기만 해야 한다.
  다시 대입하는 경우 모두 질의 함수로 추출해야한다.

> **절차**
>
> 1. 변수가 사용되기 전에 값이 확실히 결정되는지, 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다.
> 2. 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만든다.
> 3. 테스트
> 4. 변수 대입문을 함수로 추출한다.
>
>    → 변수와 함수가 같은 이름을 가질 수 없다면 함수 이름을 임시로 짓는다.
>
>    → 추출 함수가 부수 효과를 일으키지는 않는지 확인한다.
>
>    ⇒ 부수효과가 있으면, 질의 함수와 변경 함수 분리하기로 대처한다.
>
> 5. 테스트
> 6. 변수 인라인하기로 임시 변수를 제거한다.

## 7.5 클래스 추출하기

클래스는 반드시 명확히 추상화하고 소수의 주어진 역할만 처리해야 한다는 가이드라인이 있다.

But, 연산을 추가하고 데이터를 보강하면서 점점 비대해진다.

개발 후반으로 접어들면 서브 클래스가 만들어지는 방식에서 왕왕 징후가 나타나기도 한다.

**클래스는 나누어야하는 신호.**

1. 일부 데이터와 메서드를 따로 묶을 수 있다.
2. 작은 일부의 기능만을 위해 서브클래스를 만든다.
3. 서브클래스 만드는 방식이 달라진다.

> **절차**
>
> 1. 클래스의 역할과 분리할 방법을 정한다.
> 2. 분리될 역할을 담당할 클래스를 새로 만든다.
>
>    → 원래 클래스에 남은 역할과 클래스 이름이 어울리지 않으면 바꾼다.
>
> 3. 원래 클래스 생성자에서새로운 클래스 인스턴스를 생성하여 필드에 저장해준다.
> 4. 분리된 역할에 필요한 필드들을 새 클래스에 옮긴다. 하나씩 옮길 떄마다 테스트한다.
> 5. 메서드들도 새 클래스로 옮긴다.
>
>    — 이때 저수준 메서드, 즉 다른 메서드를 호출하기보다는 호출을 당하는 일이 많은 메서드부터 옮긴다. 하나씩 옮길 때마다 테스트한다.
>
> 6. 양쪽 클래스의 인터페이스를 살피며 불필요한 메서드를 제거하고, 이름도 새로운 환경에 맞게 바꾼다.
> 7. 새 클래스를 외부로 노출할지 정한다. 노출 시 새 클래스에 참조를 값으로 바꾸기를 적용한다.

## 7.6 클래스 인라인하기

클래스 인라인하기는 클래스추출하기를 거꾸로 돌리는 리팩토링이다.

**사용하는 CASE**

1. 제 역할을 못하는 클래스가 존재할 때
2. 기능을 지금과 다르게 배불하고 싶은 클래스가 있을 때

> 절차
>
> 1. 소스 클래스에 각 public 메서드에 대응하는 메서드를 타깃 클래스에 생성한다.
>    - 이 메서드들은 단순히 작업을 소스 클래스로 위임해야 한다.
> 2. 소스 클래스의 메서드를 사용하는 코드를 모두 타깃 클래스의 위임 메서드를 사용하도록 바꾼다.
>
>    → 하나씩 바꿀 때마다 테스트한다.
>
> 3. 소스 클래스의 메서드와 필드를 모두 타깃 클래스로 바꾼다
>
>    → 매번 테스트한다
>
> 4. 소스 클래스를 삭제하고 조의를 표시한다 🙏💫

## 7.7 위임 숨기기

모듈화 설계의 핵심은 **캡슐화**다.

**캡슐화**

- 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다.
- 무엇가 변경 시 고려해야 할 모듈 수가 적어진다.
  → 코드 변경에 유용하다.

**위임숨기기 CASE**

1. 서버 객체의 필드가 가리키는 객체의 메서드를 호출하려면 클라리언트는 이 위임 객체를 알아야한다.
2. 인터페이스가 바뀌면 모든 클라이언트 코드를 수정해야 한다.
3. 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다.

> **절차**
>
> 1. 위임 객체의 각 메서드에 해당하는 위임 메서드를 서버에 생성한다.
> 2. 클라이언트가 위임 객체 대신 서버를 호출하도록 수정한다.
> 3. 모두 수정했다면, 서버로부터 위임 객체를 얻는 접근자를 제거한다.
> 4. 테스트하다.

## 7.8 중개자 제거하기

**위임 숨기기의 단점**

→ 위임 객체의 기능을 사용하고 싶을 떄 마다 위임 메서드를 추가해야한다.

→ 추가하다보면 위임 메서드가 성가셔지고, 중개자 역할로 전락할 수 있다.

> **절차**
>
> 1. 위임 객체를 얻는 게터를 만든다.
> 2. 위임 메서드를 호출하는 클라이언트가 모두 이 게터를 거치도록 수정
> 3. 위임 메서드를 삭제한다.

## 7.9 알고리즘 교체하기

때로는 알고리즘 전체를 걷어내고 간결한 알고리즘으로 바꿔야 할 떄가 이다.

→ 주로 쉬운 해결 방법을 발견하거나, 내 코드와 같은 기능을 제공하는 라이브러리를 발견했을 때

⇒ 이 작업에 착수하려면 메서드가 가능한 잘게 나눴는지 확인해야 한다. (거대한 알고리즘은 교체하기 어려우니 알고리즘 간소화 작업이 선행되어야 한다.)

---

- Commit History 참조

[History for 07-chapter - dahye1013/refactoring-dh](https://github.com/dahye1013/refactoring-dh/commits/master/07-chapter)
