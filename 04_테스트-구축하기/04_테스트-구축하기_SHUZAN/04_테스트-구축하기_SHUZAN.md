리팩터링을 제대로 하려면 불가피하게 저지르는 실수를 잡아주는 견고한 테스트 스위트 (test suite)가 뒷받침돼야 한다.

**좋은 테스트 작성하는 일을 개발 효율은 높인다.**

## 4.1 자가 테스트 코드의 가치

---

프로그래머들의 실제 코드작성 시간의 비중은 크지 않다.

→ 상황 파악 / 설계 고민 / 특히 디버깅에 큰 시간을 사용한다.

⇒ 버그 수정은 대체로 금방 끝나지만, 버그를 찾는 여정에 수많은 시간이 소요된다.

— 1992년 OOPSLA 컨퍼런스에서 클래스마다 테스트 코드를 갖춰야 한다는 내용이 등장 하였다. 출력하고자 하는 값이 예상값이 맞으면 ok 출력하는 식

> 모든 테스트를 자동화하고 검사까지 스스로 검사하게 만들어라.

**장점**

1.  모든 테스트를 컴파일 만큼 쉽게 만드는 방법
2.  가장 최근 테스트로 잡은 버그를 다시 살려보면 테스트에 걸려 눈에 확 드러난다.
3.  직전까지 테스트가 성공했다면 마지막 테스트 이후에 작성한 코드에서 버그가 발생 한 것을 알 수 있다.

    → 더 작은 단위로 테스트를 추가하면 디버깅에 유리하다.

> 테스트 스위트는 강력한 버그 검출 도구로 버그를 찾는데 걸리는 시간을 대폭 줄여준다.

- **테스트 코드 작성의 좋은 시점은 프로그래밍을 시작하기 전이다.**

  1.  기능을 추가헤야 할 때 테스트부터 작성한다.

      → 구현보다 인터페이스에 집중하게 된다는 장점을 가진다.

  2.  코딩 완료 시점을 정확하게 판단 할 수 있다.

- **테스트 주도 개발**

  1. 통과하지 못할 테스트를 작성한다.

     → 테스트를 통과하게끔 코드를 작성하고 리팩토링을 짧게 반복한다.

     — 테스트-코딩-이펙터링을 여처 차례 진행하며 반복한다.

- GUI Test Runner의 이점
  - 테스트 진행시 진행상황을 빨간색과 초록색으로 볼 수 있다.
    ⇒ ‼️실패한 테스트가 하나라도 있으면 리팩토링하면 안된다.
  - 테스트 진행 상황(초록) 기준으로 버전 관리하면서 체크 포인트로 돌아가면 안정적으로 버전을 관리 할 수 있다.

## 4.3 테스트 추가하기

---

- 사용하는 테스트 프레임 워크 — 모카

- 테스트 순서
  1. 테스트에 필요하나 데이터와 객체를 뜻하는 픽스처 Fixture (고정장치)
  2. 픽스처의 속성을 검증

```jsx
describe("province", function () {
  it("shortfall", function () {
    const asia = new Province(sampleProvinceData()); //픽스처 설정
    expect(asia.shortfall).equal(5);
  });
});
```

- 실패해야 할 상황에서는 반드시 실패하게 만들자.
  → 수많은 테스트가 실패하지 않는다면, 오류를 주입하여 테스트하는 방법을 사용해도 좋다.

> 자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 하루에 한번은 전체 테스트를 돌려보자.

— 모카에서는 assertion 이라는 픽스처 검증 라이브러리를 선택하여 사용 할 수 있다.

→ 후에 다양한 자바스크립트 라이브러리를 사용하는 것도 좋은 방법이 될 수 있다.

---

## 4.4 테스트 추가하기

- **테스트는 위험요인을 중심으로 작성해야 한다.**‼️
  → 테스트의 목적은 현재 혹은 미래에 발생하는 버그를 찾는 것에 있다.
  (즉, 단순히 필드를 읽고 쓰는 접근자는 테스트 할 필요 없다)
  — 저자의 경우, 너무 많은 테스트를 만들다보면 필요한 테스트를 놓칠 수 도 있으므로, 적은 수의 테스트만으로 큰 효과를 보는 식으로 작업한다. (노력의 극대화)

> **완벽하게 만드느라 테스트를 수행하지 못하는 것보다, 불완전한 테스트를 진행하는 것이 낫다.**

**Bad 🤧**

— 테스트끼리 상호작용하게 하는 공유 픽스처를 생성한다.

```jsx
describe("province test", function () {
  const asia = new Province(sampleProvinceData()); //픽스처 설정
  it("Asia - shortfall", function () {
    expect(asia.shortfall).equal(5);
  });
  it("Asia - profit", function () {
    expect(asia.shortfall).equal(5);
  });
});
```

⇒ 버그 중 가장 지저분한 유형은 '테스트끼리 상호작용하게 하는 공유 픽스처' 를 생성하는 것이다.

→ 다른 테스트에서 이 공유 객체 값을 수정하면 이 픽스 텍스처를 사용하는 다른 테스트가 실패 할 수 있다. 즉, 테스트를 실행하는 순서에 따라 결과가 달라질 수 있다.

**Good 😊**

```jsx
describe("province test", function () {
  let asia;
  beforeEach(() => {
    asia = new Province(sampleProvinceData()); //픽스처 설정
  });

  it("Asia - shortfall", function () {
    expect(asia.shortfall).equal(5);
  });
  it("Asia - profit", function () {
    expect(asia.shortfall).equal(5);
  });
});
```

- beforeEach 구문으로 각각의 테스트 바로 전에 실행하여 초기화시킨다.
  → 픽스처를 새로 만들면 **모든 테스트를 독립적으로 구성**할 수 있다.

### 픽스처

- **픽스쳐란?**
  - 테스트에 필요한 데이터와 객체
    → 테스트마다 겹치는 픽스쳐 사용 시, 유효범위를 옮겨 테스트끼리 상호작용하는 공유 픽스쳐가 아닌 각 테스트마다 새로 설정되는 beforeEach문에서 생성합니다.
- **픽스쳐를 사용하는 이유?**
  - 표준 픽스처에 익숙해져서 테스트 할 속성을 다양하게 찾을 수 있다.
  - 코드를 읽는 사람들이 모두 describe 블록 안에서 같은 기존 데이터로 시작한다는 것을 알 수 있다.

[4-1. 개요](https://yujeongjeon.github.io/Chapter%2004%20-%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/pages/previous.html)

## 4.5 픽스처 수정하기

---

- 사용자가 값을 변경하면서 픽스처의 내용도 수정되는 경우가 흔하다.
- 대부분의 수정은 세터에서 이루어진다.
  → 보통 세터가 아주 단순하여 버그가 생길 일도 잘 없으므로 테스트 하지 않는다.

### 표준 픽스처 변경 검증

- Setup-exercise-verify
  - (설정 — 실행 — 검증)
- Given-when-then
  - (조건 — 발생 — 결과 )
- Arrage-act-assert
  - ( 준비 — 수행 — 단언 )

1. 이 세가지 단계가 한 테스트 안에 모두 담겨 있을 수 있다.
2. 공통 되는 부분을 beforeEach와 같은 표준 설정 루틴에 모아서 처리하기도 한다.

```jsx
it("change production", () => {
  asia.producers[0].production = 20;
  expect(asia.shortfall).equal(-6);
  expect(asia.profit).equal(292);
});
```

→ 이 코드는 구문 하나당 검증을 하나씩만 한다.

- 이러 경우, 나머지 검증은 실행해보지 못하고 테스트가 실패한다.
- 한 테스트로 묶어도 문제되지 않을 정도로 속성이 밀접하다고 판단하는 경우이다.
- 아래와 같이 분리할 수 있다.

```jsx
it("Change production - shortFall", () => {
  asia.producers[0].production = 20;
  expect(asia.shortfall).equal(-6);
});
it("Change production - profit", () => {
  asia.producers[0].production = 20;
  expect(asia.profit).equal(292);
});
```

## 4.6 경계 조건 검사하기

---

- **happy path에 대한 테스트 작성도 필요하다**
  - happy path?
    모든 일이 순조롭고 사용자도 우리 의도대로 사용하는 상황이다.

```jsx
it("demand - zero", () => {
  asia.demand = 0;
  expect(asia.shortfall).equal(-25);
  expect(asia.profit).equal(0);
});
it("demand - minus", () => {
  asia.demand = -1;
  expect(asia.shortfall).equal(-26);
  expect(asia.profit).equal(-10);
});
```

**수요가 음수인 경우?**

→ 수요가 음수라고 하여, 음수의 이익이 나오는 것은 고객 관점에서 말이되지 않는다.

⇒ 이처럼 경계를 확인하는 테스트를 작성하면, 특이 상황 처리를 어떻게 할지 알 수 있다.

> 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.

```jsx
describe("string for producers", () => {
  it("", () => {
    const data = {
      name: "String producers",
      producers: "",
      demand: 30,
      price: 20,
    };
    const prov = new Province(data);
    expect(prov.shorfall).equal(0);
  });
});
```

- 실패 → 검증 단계에서 실제 값이 예상과 다르게 벗어났다고 표기한다
  - 에러와 다르다.

**이런 상황에서의 해결방안**

1. 에러 상황을 더 잘 처리하도록 코드 추가
2. 의미 있는 오류 메시지 출력
3. producers 를 빈 배열로 설정한다.

같은 모듈 사이에 유효성 검사(validation check)가 너무 많으면?

→ 다른 곳에서 확인 한 것을 중복 검증하여 문제가 될 수 있다.

→ Json으로 인코딩 된 요청처럼 외부에서 들어오는 입력 객체는 유효한지 확인해봐야 한다.

오류로 인해 프로그램 내부에 잘못된 데이터가 흘러서 디버깅하기 어려운 문제가 발생한다면?

→ 어서션 추가하기 (10.6장) 을 통하여 오류가 최대한 빨리 들어나도록 하다.

테스트는 어느 수준까지 해야 하는가?

→버그 없는 완벽한 프로그램은 없지만, 테스트가 개발 속도를 올리는 것은 맞는 말이다.

→ 하지만, 테스트도 수확 체감 법칙 (law of diminishing returns)가 적용된다.

→ 테스트를 너무 많이 작성하면 의욕이 떨어져서 하나도 작성하지 않는 경우가 생긴다.

**추천하는 수준**

1. 위험한 부분에 집중한다.
2. 처리 과정이 복잡한 부분을 찾는다.

   → 안심하고 리팩터링할 수 있는 보호막을 만든다.

## 4.7 끝나지 않은 여정

---

- 테스트는 반복적으로 진행되어야 한다.
  1. 기존 테스트가 명확한지
  2. 이해하기 쉽게 리팩토링 가능한지
  3. 제대로 검사하는지
  다음의 기준을 가지고 보강한다.

> 버그 리포트를 받으면, 가장 먼저 그 버그를 들어내는 단위 테스트를 작성하자.

- 테스트의 명확한 기준은 없다.
  - 테스트 커버리지의 경우, 영역 찾기에 도움을 주지 테스트 스위트(test suite)와는 상관없다.
    → 리팩터링 후 테스트 결과가 초록색인 것만 보고, 리팩터링 과정에서 생겨난 버그가 없다고 확실 할 수 있다면 좋은 테스트 스위트이다.
