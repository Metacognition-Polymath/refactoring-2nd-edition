# 04. 테스트 구축하기

- 리팩터링 <- 견고한 테스트(test suite)가 뒷받침 돼야 한다
- 리팩터링을 하지 않더라도 좋은 테스트를 작성하는 일은 개발 효율을 높여준다

## 4.1 자가 테스트 코드의 가치

- 프로그래머 - 실제로 코드를 작성하는 시간의 비중은 그리 크지 않음
  - 대부분 디버깅에 시간을 많이 쓰는데 특히 버그를 찾는 시간이 오래 걸림

**모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자.**

**테스트 스위트는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.**

- 테스트를 자동화한다면 테스트 코드를 작성하는 재미가 꽤 쏠쏠하다

- 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다.

- 기능을 추가해야할 때 테스트부터 작성한다
- 테스트를 작성하다보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다.
- 구현보다 인터페이스에 집중하게 된다는 장점도 있다(무조건 좋은 일이다)
- 코딩이 완료되는 시점을 정확하게 판단할 수 있다

  - 테스트를 모두 통과한 시점 : 코드를 완성한 시점

- 켄트 벡 - 테스트부터 작성하는 습관 : 테스트 주도 개발(Test-Driven Development : TDD)
  - (처음엔 통과하지 못할) 테스트를 작성하고
  - 이 테스트를 통과하게끔 코드를 작성하고
  - 결과 코드를 최대한 깔금하게 리팩터링하는 과정
  - 이 과정을 짧은 주기로 반복한다
- 테스트 -> 코딩 -> 리팩터링

  - 한 시간에도 여러 차례 진행

- 테스트 코드 : 적은 노력으로 엄청난 효과

- 테스트가 갖춰지지 않은 코드를 리팩터링해야 할 때 => 리팩터링보다 자가 테스트 코드 부터 작성

## 4.2 테스트할 샘플 코드

- 사용자가 생산 계획을 검토하고 수정하도록 해주는 간단한 애플리케이션의 일부
  - 생산 계획 : { 각 지역의 수요, 가격 }
  - 지역에 위치한 생산자 : 각기 제품을 특정 가격으로 특정 수량만큼 생산할 수 있음
  - UI는 생산자별로 제품을 모두 판매했을 때 얻는 수익도 보여줌
  - 화면 맨아래 - (수요 - 총샌산량 : 생산 부족분), 현재 계획에서 거둘 수 있는 총수익
- 이번 장에선 비지니스 로직을 바탕으로 테스트 코드 작성하는 방법에 집중
- 비지니스 로직 -> 클래스 두 개 : 생산자(Producer), 지역 전체(Province)
  - Province의 생성자 : JSON문서로 부터 만들어진 Javascript 객체를 인수로 받음

## 4.3 첫 번째 테스트

#### 테스트 프레임워크

- 책 : Mocha
- 나 : Jest
  - Jest를 선택한 이유 : 이전에 사용해봤고 더 많이 사용되는 것 같아서

#### 테스트 스위트 구조

- 테스트는 it 블록에 담긴다

1. 테스트에 피러요한 데이터와 객체를 뜻하는 픽스처(fixture:고정장치)를 설정한다

- 샘플 지역 정보로 부터 생성한 Province 객체를 픽스처로 설정

2. 픽스처의 속성들을 검증

#### describe vs it

- 개발자 마다 부연 설명용 문자열을 써 넣는 방식이 다름
- 테스트가 무엇을 검사하는지 설명
- 또는 명확한 코드에선 그냥 비워두는 사람도 있음
- 보통은 실패한 테스트가 무엇인지 식별할 수 있을 정도로 작성

#### 실패해야 할 상황에서는 반드시 실패하게 만들자

- 수 많은 테스트를 실행했음에도 실패하는 게 없다면 테스트가 내 의도와 다른 방식으로 코드를 다루는 건 아닌지 확인
  - 코드에 일시적으로 오류를 주입

**자주 테스트 하라. 작성중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자.**

#### 리팩터링 전엔 모든 테스트를 통과시키자

## 4.4 테스트 추가하기

- 클래스가 하는 일을 모두 살펴보고 각각의 기능에서 오류가 생길 수 있는 조건을 하나씩 테스트하는 식으로 진행
  - 테스트는 위험요인 중심으로 작성해야 한다! - public 메서드를 모두 테스트하는 것과 다르다
- 테스트의 목적은 현재 혹은 향후에 발생하는 버그를 찾는데 있다
- 테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽기 때문에 아주 중요한 포인트다

**완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다.**

#### 테스트간 중복 제거

```ts
// 4장.test.ts
// bad : 테스트 버그 중 가장 지저분한 유형 : 테스트 끼리 상호작용하게 하는 공유 픽스처
describe("province", function () {
  const asia = new Province(sampleProvinceData()); // bad

  it("shorfall", function () {
    expect(5).toEqual(asia.shortfall);
  });

  it("profit", function () {
    expect(asia.profit).toEqual(230);
  });
});

// good
describe("province", function () {
  let asia: Province;
  beforeEach(function () {
    asia = new Province(sampleProvinceData());
  });

  it("shorfall", function () {
    expect(5).toEqual(asia.shortfall);
  });

  it("profit", function () {
    expect(asia.profit).toEqual(230);
  });
});
```

- beforeEach 구문 : 각각의 테스트 바로 전에 실행

  - asia를 초기화 히기 때문에 모든 테스트가 자신만의 새로운 asia를 사용하게 됨

- 테스트가 눈에 띄게 느려진다면 불변임을 확실한 상태에선 공유 픽스처를 사용하기도 함
  - 공유 픽스처를 사용하다가 저지른 실수 때문에 디버깅하는데 엄청난 고생을 할 가능성이 높음

## 4.5 픽스처 수정하기

- 지금까지 : 테스트코드 - 픽스처를 불러와서 그 속성을 확인
- 실전 : 사용자가 값을 변경하면서 픽스처의 내용도 수정되는 경우가 흔함
  - 이러한 수정 : 세터에서 이뤄짐
    - 보통 세터는 간단하기 때문에 테스트하지 않지만
    - production()세터는 좀 복잡한 동작을 수행하기 때문에 테스트 필요

```ts
// describe('province', ...)
it("change production", function () {
  asia.producers[0].production = 20;
  expect(asia.shortfall).toEqual(-6);
  expect(asia.profit).toEqual(292);
});
// 이 테스트는 it 구문 하나에서 두가지 속성을 검증 - 일반적으로 하나씩 하는게 좋음
// 앞쪽 검증을 통과하지 못 하면 나머지 검증은 실행해보지 못하고 테스트 실패 -> 실패원인 파악하는데 유용한 정보를 놓칠 수 있음
// 여기에선 한 테스트로 묶어도 문제되지 않을 정도로 두 속성이 밀접하다고 판단하여 이렇게 작성
```

#### 설정(setup) - 실행(exercise) - 검증(verify) 패턴

- beforeEach : 픽스처 `설정`
- 테스트 : `수행`
- 기대한 대로 처리 했는지 `검증`

#### == 조건(given) - 발생(when) - 경과(then)

#### == 준비(arrange) - 수행(act) - 단언(assert)

- 초기 준비 작업 중 공통되는 부분 : beforeEach와 같은 표준 설정 루틴에 모아서 처리

## 4.6 경계 조건 검사하기

- 지금까진 순조롭고 사용자도 의도대로 사용하는 happy path상황에 집중하였음
- 이 범위를 벗어나는 경계 지점에서 문제가 생기면 어떤일이 벌어지는지 확인하는 테스트도 함께 작성해주면 좋음
- 경계 조건 예시
  - producers가 없을 때
  - 수요가 없을 때
  - 수요가 마이너스 일 때

```ts
it("negative demand", function () {
  // 수요가 마이너스일 때 : 경계조건 테스트
  asia.demand = -1;
  expect(asia.shortfall).toEqual(-26);
  expect(asia.profit).toEqual(-10);
});
```

- 의문점 -> 수요가 음수일 때 수익이 음수가 나온다는 것이 말이 되는 걸까?
  - 수요의 최솟값은 0이어야 하지 않을까?
  - => 테스트를 작성해보면 프로그램에서 이런 특이 상황을 어떻게 처리하는 게 좋을지 생각해볼 수 있다

**문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.**

- 프로그램의 세터들은 의미상 숫자만 받아야 하지만 UI로 부터 문자열을 취하고 있다

  - 필드가 아에 비어 있을 수도 있고, 의도한 대로 잘 처리하는지 반드시 확인해야 한다

- 내가 작성한 코드를 적으로 돌림

  - 의식적으로 프로그램을 망가 뜨림
  - 생산성과 재미를 끌어올려줌 <- 마음속 잠재하는 사악한 욕구를 충족시켜주기 때문

- 외부입력객체(JSON으로 인코딩된 요청 같은 것)는 유효한지 확인해봐야 하므로 테스트를 작성한다
  - 어떤 경우든 경계 조건을 검사하는 테스트를 작성하다 보면 이런 고민들을 하게 된다
  - 리팩터링 전이라면 이런 테스트는 작성하지 않음
    - 리팩터링은 겉보기 동작에 영향을 주지 않아야 함
    - 이런 오류는 겉보기 동작에 해당하지 않음
    - 경계조건에 대응하는 동작이 리팩터링 때문에 변하는지 신경 쓸 필요는 없음

**어차피 모든 버그를 잡아낼 수 없다고 생각하여 테스트를 작성하지 않는다면 대다수 버그를 잡을 수 있는 기회를 날리는 셈이다**

#### 테스트는 어느 수준까지 해야 할까?

- 수확체감 법칙(Law of diminishing returns)이 테스트에도 적용 됨
- 테스트를 너무 많이 작성하다보면 오히려 의욕이 떨어져 나중엔 하나도 작성하지 않게 될 위험도 있음
- 따라서 오히려 위험한 부분에 집중하는 게 좋다
- 코드에서 처리 과정이 복잡한 부분을 찾아보자
- 함수에서 오류가 생길만한 부분을 찾아보자
- 테스트가 모든 버그를 걸러주진 못 하더라도 안심하고 리팩터링할 수 있는 보호막은 되어준다
- 그리고 리팩터링 하면서 프로그램을 더욱 깊이 이해하게 되어 더 많은 버그를 찾게 된다
- 테스트 스위트부터 갖춘 뒤 리팩터링하지만
- 리팩터링하는 동안에도 계속해서 테스트를 추가한다

## 4.7 끝나지 않은 여정

- 테스트는 리팩터링에 반드시 필요한 토대일 뿐만 아니라, 그 자체로도 프로그래밍에 중요한 역할을 한다
- 테스트의 용이성(testability)를 아키텍처 평가 기준으로 활용하는 사례도 많다
- 이 장에서 보여준 테스트는 단위 테스트(unit test)에 해당
  - 작은 영역만 빠르게 실행되도록 설계된 테스트
- 자가 테스트 시스템은 대부분 단위 테스트가 차지 한다
- 테스트의 종류
  - 단위 테스트
  - 컴포넌트 사이의 상호작용에 집중하는 테스트
  - 소프트웨어의 다양한 계층의 연동을 검사하는 테스트
  - 성능 문제를 다루는 테스트 등
- 한번에 완벽한 테스트를 갖출 순 없다
  - 제품 코드 못지 않게 테스트 스위트도 지속해서 보강한다
- 기능을 새로 추가할 때 마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다
  - 기존 테스트가 명확한지, 테스트 과정을 더 이해하기 쉽게 리팩터링 할 수는 없는지, 제대로 검사하는지 등

**버그 리포트를 받으면 가장 먼저 그 버그를 명확히 잡아내는 단위 테스트부터 작성하자**

- 테스트 커버리지 분석은 코드에서 테스트 하지 않은 영역을 찾는 데만 도움될 뿐, 테스트 스위트의 품질과는 상관없다

- 테스트 스위트가 충분한지 평가하는 기준은 주관적이다
- 제품 코드보다 테스트 코드를 수정하는 데 시간이 더 걸린다면, 테스트 때문에 개발 속도가 느려진다고 생각되면
  - 테스트가 과하게 작성된건 아닌지 의심해보자
  - 하지만 너무 많은 경우보다 너무 적은 경우가 훨씬 많다
