# Chapter 10. 조건부 로직 간소화

- 조건부 로직 - 프로그램 힘 강화 & 프로그램을 복잡하게 만드는 원흉
- 조건부 로직을 이해하기 쉽게 바꾸는 리팩터링

  - 복잡한 조건문 : 조건문 분해하기 10.1
  - 논리적 조합을 명확하게 다듬기 : 중복 조건식 통합하기 10.2
  - 함수의 핵심 전 검사필요 시 : 중첩 조건문을 보호 구문으로 바꾸기 10.3
  - 똑같은 분기로직(주로 switch문)이 여러 곳에 등장한다면 : 조건부 로직을 다형성으로 바꾸기 10.4

- null과 같은 특이 케이스 처리 : 특이 케이스 추가하기(또는 null 객체 추가하기) 10.5
- 프로그램의 상태를 확인하고 그 결과에 따라 다르게 동작해야 하는 상황이면 : 어서션 추가하기 10.6
- (웹 버전에 있는 것) 제어 플래그를 이용해 코드 동작 흐름을 변경하는 코드 -> 제어 플래그를 탈출문으로 바꾸기 10.7

## 10.1 조건문 분해하기

### 10.1.1 조건문 분해하기 - 개요

```js
// before
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)) {
  charge = quantity * plan.summerRate;
} else {
  charge = quantity * plan.regularRate + plan.regularServiceCharge;
}

// after
if (summer()) {
  charge = summerCharge();
} else {
  charge = regularCharge();
}
```

### 10.1.2 조건문 분해하기 - 배경

- 복잡한 조건부 로직은 프로그램을 복잡하게 만든다.
- 조건문은 무슨일이 일어나는지 이야기해주지만 '왜' 일어나는지는 제대로 말해주지 않을 때가 많은 것이 문제다.
- 각 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수호출로 바꿔주자
- 함수 추출하기(6.1)를 적용한 한 사례로 볼 수 있다. 하지만 연습용으로 훌륭하기 때문에 독립된 리팩터링으로 추가함

### 10.1.3 조건문 분해하기 - 절차

- 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출(6.1)한다.

## 10.2 조건식 통합하기

### 10.2.1 조건식 통합하기 - 개요

```js
// before
if (anEmployee.seniority < 2) return 0;
if (anEmployee.monthsDisabled < 12) return 0;
if (anEmployee.isPartTime) return 0;

// after
if (isNotEligibleForDisability()) return 0;
function isNotEligibleForDisability() {
  return (
    anEmployee.seniority < 2 ||
    anEmployee.monthsDisabled < 12 ||
    anEmployee.isPartTime
  );
}
```

### 10.2.2 조건식 통합하기 - 배경

- 비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들
- 어차피 같은 일을 할 거라면 조건 검사도 하나로 통합하는게 낫다.
- 조건부 코드를 통합하는게 중요한 이유 두 가지
  - 첫째, 여러 조각으로 나누니 조건들을 하나로 통합함으로써 내가 하려는 일이 더 명확해진다.
  - 둘째, 이 작업이 함수 추출하기(6.1)까지 이어질 가능성이 높기 때문이다.
    - 함수 추출하기 : '무엇'을 하는지를 '왜' 하는지 말해주는 효과적인 도구
- 하나의 검사라고 생각할 수 없는, 다시 말해 진짜로 독립된 검사들이라고 판단되면 이 리팩터링을 하면 안 된다.

### 10.2.3 조건식 통합하기 - 절차

1. 해당 조건식들 모두에 부수효과가 없는지 확인한다.

- 부수효과가 있는 조건식들에는 질의 함수와 변경 함수 분리하기(11.1)를 먼저 적용한다.

<details>
<summary>질의 함수</summary>

명령-질의 분리 원칙
부수효과가 없는 코드들 끼리는 마음대로 배치할 수 있다. 현명한 프로그래머들은 부수효과가 없는 코드로 프로그래밍하려 한다. 부수효과를 없애기 위한 좋은 원칙 중 하나는 명령 질의 분리 원칙을 지키는 것이다.

명령 함수 : 동작의 수행

질의 함수 : 연산을 통해 답을 구하는 행위. 질의는 내부 또는 외부의 값을 변경하여 부수효과를 만들어선 안된다.

- 참고 : https://kok202.tistory.com/318

</details>

2. 조건문 두 개를 선택하여 두 조건문은 or로 결합하고, 중첩된 조건문은 and로 결합한다.
3. 테스트한다.
4. 조건이 하나만 남을 때 까지 2~3 과정을 반복한다.
5. 하나로 합쳐진 조건식을 함수로 추출(6.1)할지 고려해본다.

## 10.3 중첩 조건문을 보호 구문으로 바꾸기

### 10.3.1 중첩 조건문을 보호 구문으로 바꾸기 - 개요

```js
// before
function getPayAmount() {
  let result;
  if (isDead) {
    result = deadAmount();
  } else {
    if (isSeparated) {
      result = separatedAmount();
    } else {
      if (isRetired) {
        result = retiredAmount();
      } else {
        result = normalPayAmount();
      }
    }
  }
  return result;
}

// after
function getPayAmount() {
  if (isDead) {
    return deadAmount();
  }
  if (isSeparated) {
    return separatedAmount();
  }
  if (isRetired) {
    return retiredAmount();
  }
  return normalPayAmount();
}
```

### 10.3.2 중첩 조건문을 보호 구문으로 바꾸기 - 배경

- 조건문은 주로 두 가지 형태로 쓰인다
  - 참인 경로와 거짓인 경로 모두 정상동작으로 이어지는 형태
  - 한쪽만 정상인 형태
- 두 형태는 의도하는 바가 서로 다르므로 그 의도가 코드에 드러나야 한다.

  - 두 경로 모두 정상 동작이라면 if - else를 사용한다.
  - 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음,
    조건이 참이면(비정상이면) 함수에서 빠져나온다. -> 보호 구문(guard clause)이라고 한다.

- 진입점은 하나이지만 반환점은 여러개 일 수 있다 -> 코드에선 명확함이 핵심이다.
  - 만약 반환점이 하나일 때 함수의 로직이 더 명백하다면 그렇게 해도 된다.

### 10.3.3 중첩 조건문을 보호 구문으로 바꾸기 - 절차

1. 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꾼다.
2. 테스트한다.
3. 1~2 과정을 필요한 만큼 반복한다.
4. 모든 보호 구문이 같은 결과를 반환한다면, 보호 구문들의 조건식을 통합(10.2) 한다.

## 10.4 조건부 로직을 다형성으로 바꾸기

### 10.4.1 조건부 로직을 다형성으로 바꾸기 - 개요

```js
// before
switch (bird) {
  case "유럽 제비":
    return "보통이다";
  case "아프리카 제비":
    return bird.numberOfCoconuts > 2 ? "지쳤다" : "보통이다";
  case "노르웨이 파랑 앵무":
    return bird.voltage > 100 ? "그을렸다" : "예쁘다";
  default:
    return "알 수 없다";
}

// after
class EuropeanSwallow {
  get plumage() {
    return "보통이다";
  }
}

class AfricanSwallow {
  get plumage() {
    return this.bird.numberOfCoconuts > 2 ? "지쳤다" : "보통이다";
  }
}

class NorwegianBlueParrot {
  get plumage() {
    return this.bird.voltage > 100 ? "그을렸다" : "예쁘다";
  }
}
```

### 10.4.2 조건부 로직을 다형성으로 바꾸기 - 배경

- 복잡한 조건부 로직은 프로그래밍에서 해석하기 가장 난해한 대상에 속한다.
- 조건부 로직을 직관적으로 구조화할 방법을 항상 고민한다

  - 종종 더 높은 수준의 개념을 도입해 이 조건들을 분리해낼 수 있다.
  - 조건문 구조를 그대로 둔 채 해결될 때도 있지만, 클래스와 다형성을 이용하면 더 확실하게 분리할 수도 있다.

- 타입을 여러개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 처리하도록 구성하는 방법 - 일반적으로 switch문

  - case별로 클래스를 하나씩 만들어 공통 switch로직의 중복을 없앨 수 있다.
  - 다형성을 활용하여 어떻게 동작할지를 각 타입이 알아서 처리하도록 하면 된다. (??)

- (또 다른 예)기본 동작을 위한 case문과 그 변형 동작으로 구성된 로직을 떠올릴 수 있다.

  - 기본동작 : 가장 일반적이거나 가장 직관적인 동작
    - 슈퍼클래스로 넣어서 변형 동작에 신경 쓰지 않고 기본에 집중
  - 변형 동작을 뜻하는 case들을 각각의 서브클래스로 만든다.
    - 이 서브클래스들을 기본 동작과의 차이를 표현하는 코드로 채워질 것

- 다형성은 객체 지향 프로그래밍의 핵심
  - 하지만 남용하기 쉽다.
  - 모든 조건부 로직을 다형성으로 대체해야된다는 것에 동의하지 않는다.
  - 하지만 앞서 이야기한 방법들로 개선할 수 있는 복잡한 조건부 로직을 발견하면 다형성이 막강한 도구임을 깨닫게 된다.

### 10.4.3 조건부 로직을 다형성으로 바꾸기 - 절차

1. 다형적 동작을 표현하는 클래스들이 아직 없다면 만들어준다.
   이왕이면 적합한 인스턴스를 알아서 만들어 반환하는 팩터리 함수도 함께 만든다.
2. 호출하는 코드에서 팩터리 함수를 사용하게 한다.
3. 조건부 로직 함수를 슈퍼클래스로 옮긴다.

- 조건부 로직이 온전한 함수로 분리되어 있지 않다면 먼저 함수로 추출(6.1)한다.

4. 서브클래스 중 하나를 선택한다. 서브클래스에서 슈퍼클래스의 조건부 로직 메서드를 오버라이드한다.
   조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사한 다음 적절히 수정한다.
5. 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다.
6. 슈퍼클래스 메서드에는 기본 동작 부분만 남긴다.
   혹은 슈퍼클래스가 추상 클래스여야 한다면, 이 메서드를 추상으로 선언하거나 서브클래스에서 처리해야 함을 알리는 에러를 던진다.
