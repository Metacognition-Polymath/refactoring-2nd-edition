### Sample Code & Commit History

[refactoring-dh/10-chapter at ch10 · dahye1013/refactoring-dh](https://github.com/dahye1013/refactoring-dh/tree/ch10/10-chapter)

[History for 10-chapter - dahye1013/refactoring-dh](https://github.com/dahye1013/refactoring-dh/commits/ch10/10-chapter)

## 10.1 조건문 분해하기

- 복잡한 조건문 로직은 프로그램을 복잡하게 만드는 원흉이다.
  - 다양한 조건 → 긴 함수 → 읽기 어려움
    ⇒ 조건 검사하고, 그 결과에 따른 동작은 표현한 코드는 무슨일이 일어나는지 말하지만, **왜 일어나는지** 제대로 말해주지 않을 떄가 많다.
- 거대한 코드 블록이 주어지면 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살린 이름의 함수 호출로 바꿔주자.
  ⇒ 전체적인 의도가 더 잘 드러난다.

## 10.2 조건식 통합하기

- 비교하는 조건은 다르지만, 결과로 수행하는 동작은 똑같은 코드
  ⇒ 조건 검사도 하나로 통합하는 것이 좋다.
  ⇒ and 연산자와 or 연산자를 사용하여 로직을 합친다.

### **조건부 코드를 통합하는 이유**

1. 여러 조각으로 나뉜 조건을 하나로 통합

   → 하려는 일을 명확히한다.

2. 함수 추출하기로 이어질 가능성이 높다

   → 복잡한 조건식을 함수로 추출하는 코드의 의도가 훨씬 분명하게 드러나는 경우가 많다.

   — `함수추출하기` 는 기술하던 코드를 ‘왜’ 하는지 말해주는 효과적인 도구이다.

## 10.3 중첩 조건문을 보호 구문으로 바꾸기

조건문은 주로 두 가지 형태로 쓰인다.

1. 참인 경로와 거짓인 경로 모두 정상

   → `if` , `else`절을 사용

2. 한쪽만 정상

   → 비정상 조건을 if에서 검색하고, 정상이면 빠져나온다.

   **⇒ 보호 구문 (guard clause)**

`**보호 구문으로 바꾸기`** 핵심은 **의도를 부각하는데 있다\*\*.

if-then-else는 if과 else절에 똑같은 무게를 두어 똑같이 중요하다는 뜻을 전달한다.

→ 보호구문은 조치 후 함수에서 빠져나오게 한다.

## 10.4 조건부 로직을 다형성으로 바꾸기

조건문 구조를 그대로 둔 채 해결될 때도 있지만, **클래스와 다형성을 이용하면 더 확실하게 분리 할 수 있다.**

타입을 여러개 만들고 각 타입이 조건부 로직을 자신만의 방식으로 저리하도록 구성해야 한다.

ex) 책, 음악, 음식은 다르게 처리해야한다.

→ 타입이 다르니까!

1. case별로 클래스를 하나씩 만들어서 공통 switch 로직의 중복을 없앨 수 있다. 다형성을 활용하여 어떻게 동작할지 각 타입이 알아서 처리하도록 하면 된다.
2. case문과 병형 동작으로 구성된 로직

   로직을 슈퍼 클래스에 넣어서 변형 동작에 신경쓰지 않고, 기본에 집중하게 한다. 그런 다음 변형 동작을 뜻하는 case들로 서브클래스를 만든다.

**⇒ 다형성은 객체 지향 프로그래밍이다.**

→ 복잡한 조건부 로직을 발견하면 다형성이 막강한 도구임을 깨닫게 된다.

> **절차**
>
> 1. 다형성 동작을 표현하는 클래스가 없다면 만들어준다.
>
>    — 이왕이면 적합한 인스턴스를 만들어 반환하는 팩터리 함수도 만든다.
>
> 2. 호출하는 코드에서 팩터리 함수를 사용하게 한다.
> 3. 조건부 로직 함수를 슈퍼클래스로 옮긴다.
> 4. 서브클래스 중 하나를 선택한다. 서브클래스에서 슈퍼클래스의조건부 로직 메서드를 오버라이드한다. 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사하고 적절히 수정한다.
> 5. 같은 방식으로 각 조건절을 해당 서브클래스에서 메서드로 구현한다.
> 6. 슈퍼 클래스 메서드에서 기본 동작 부분을 남긴다.

자바스크립트는타입 계층 구종 없이도 다형성을 표현할 수 있다.

객체가 적절한 이름의 메서드만 구현하고 있다면 문제없이 같은 타입으로 취급하기 때문이다.

**⇒ 덕타이핑 (duck typing)**

```jsx
class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject);
  }

  get plumage() {
    switch (this.type) {
      default:
        return "unknown"; //기본 동작
    }
  }

  get airSpeedVelocity() {
    switch (this.type) {
      default:
        return null;
    }
  }
}

//Bird subclass - 종별 서브 클래스
class EuropeanSwallow extends Bird {
  get plumage() {
    return "average";
  }
  get airSpeedVelocity() {
    return 35;
  }
}
```

→ 이 경우에도 슈퍼클래스 `Bird` 가 없어도 되지만, 클래스 관계를 잘 설명해주므로 놔두어도 좋다.

_상속은 똑같은 객체지만, 다른 부분도 있음을 표현할때 상속을 사용한다._

## 10.5 특이케이스 추가하기

특정 값에 똑같이 반응하는 코드가 여러곳이라면 반응을 한 곳으로 모으는 것이 효율적이다.

특수한 경우의 공통 동작은 하나로 모아서 사용하는 것을 **`특이케이스 패턴`**이라고 한다

→ 이 패턴을 활용하면 특이 케이스 확인 코드를 단순한 함수 호출 로 바꿀 수 있다.

### 특이케이스 형태

1. **단순 데이터 읽기**

   → 리터럴 객체 형태로 준비한다.

2. **데이터 읽기 이상의 동작 수행**

   → 메서드를 담은 객체로 생성(ex.클래스)

3. **널은 특이 케이스로 처리해야 할 때가 많다. — null object pattern**

### 절차

> 1. 컨테이너에 특이 케이스인지 검사하는 속성을 추가하고, false반환
> 2. 특이 케이스 객체를 만든다.
>
>    → 특이 케이스인지 검사하는 속성만 포함하고, 속성 true
>
> 3. 클라이언트에서 특이 케이스인지 검사하는 코드를 함수로 추출
> 4. 특이 케이스 대상 추가
> 5. 특이 케이스를 검사하는 본문 수정
> 6. 테스트
> 7. 클래스 묶기, 변환 함수로 묶기를 적용하여 특이 케이스를 처리하는 공통 동작을 새로운 요소로 옮긴다.
> 8. 특이 케이스 검사 함수를 이용하는 곳이 남아있다면 검사 함수를 인라인 <?

## 10.6 어서션 추가하기

특정 조건이 참일 떄만 제대로 동작하는 코드 영역이 있을 수 있다.

→ 어서션을 이용하여 코드 자체 삽입하는 방법을 사용할 수 있다.

**어서션(Assertion)?**

— 항상 참이라고 가정하는 조건부 문장이다.

—프로그램이 어떤 상태임을 가정한 채 실행되는지 협업 개발자에게 알려주는 훌륭한 소통 도구

— 디버깅하기 편하며, 소통 수단으로 가치가 있다.

- 특히, 오류 출처를 특정하기 어려울 때 제 값을 한다.

### 절차

> 참이라고 가정하는 조건이 보이면 조건을 명시하는 어서션을 추가한다.

## 10.7 제어 플래그를 탈출문으로 바꾸기

**제어플래그?**

- 코드의 동작을 변경하는데 사용되는 변수
- 어딘가에서 값을 계산하여 플래그에 설정한 후, 어딘가 조건문에서 검사하는 형태
  → 악취
  ⇒ 리팩토링으로 간소화할 수 있음에도 복잡하게 작성된 코드에 흔히 나타난다.
- 주 서식지는 반복문이다.

### 절차

1. 제어 플래그를 사용하는 코드를 함수 추출할지 고려한다.
2. 제어 플래그를 갱신하는 코드 각각을 적절한 제어문으로 바꾼다.
3. 수정되면 제어 플래그를 제거한다.
