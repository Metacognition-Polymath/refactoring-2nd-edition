# 10 조건부 로직

- 프로그램의 힘을 강화하는데 크게 기여하지만 복잡하게 만든 주요 원흉
- 복잡한 조건문 => 조건문 분해하기
- 논리적 조합을 명확하게 다듬는 데는 중복 조건식 통합하기
- switch 조건부 로직 당형성으로 바꾸기
- null 특이 케이스 추가하기
- 어서션 추가하기

## 10-1 조건문분해하기
 ### 배경 
- 프로그램의 힘을 강화하는데 크게 기여하지만 복잡하게 만든 주요 원흉
- 직설적이지가 않다.
- 코드가 클수록 블록을 만들어서 함수 호출로 바꾸면 전체적인 의도가 더 확실히 드러낸다.
- 조건문이 보이면 각 조건절에 이 작업이 중요하다.

### 절차
 1) 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출한다.

## 10-2 조건식 통합하기
 ### 배경 
- 비교한느 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 더러 있따
- 어차피 같은일을 할꺼면 하나로 통한하는게 낫다.
- 여러 조각을 합쳐서 내가 하련는 일이 더 명확해진다.
- 이 작업이 함수 추추랗기 까지 이어질수잇다.
- 왜를 말해주는 코드가 효과적이다
- 독립적이라고 느끼면 하면안된다.
### 절차
 1) 해당 조건식들 모두에 부수효과가 없는지 확인한ㄷ(질의함수, 변경 함수 분리 하기 먼저 적용)
 2) 조건문 두 개를 선택하여 두 조건문의 조건식들을 논리 연산자로 결합한다.
    - 순차적으로 이루어지는 조건문은 or로 결합하고, 중첩된 조건문은 and로 결합한다.
 3) 테스트한다.
 4) 조건이 하나만 남을 때까지 과정을 반복
 5) 하나로 합ㅁ쳐진 조건식을 함수로 추출할지 고려해본다.

## 10-3 중첩 조건문을 보호 구문으로 바꾸기

## 10-4 조건식 로직을 다형성으로 바꾸기

## 10-5 특이 케이스 추가하기

---

## 10-6 어서션 추가하기
~~~javascript
  if (this.discountRate)
	base = base - (this.discountRate * base);
~~~
###                 
~~~javascript
console.assert(this.discountRate > 0);
if (this.discountRate)
	base = base - (this.discountRate * base);
~~~
### 배경
- 특정 조건일때 참인 동작인 코드가 존재함
- 제곱근계산입력이 양수일때만 정상 동작한다.
- 어서션(항상 참이라는 가정 조건부 문장, 프로그래머가 잘못햇다는 뜻, 시스템에 영향을 주면안된다.)
### 절차
- 참이라고 가정하는 조건이 보이면 그 조건을 명시하는 어서션을 추가한다.

---

### 10-7 제어플래그를 탈출문으로 바꾸기

~~~javascript
   for (const p of people) {
	if (!found) {
		if (p === '조커') {
			sendAlert();
			found = true;
		}
	}
}
~~~

~~~javascript
 for (const p of people) {
	if (p === '조커') {
	    sendAlert();
		break;
	}
}
~~~

### 배경

- 제어 플래그란 코드의 동작을 변경하는 데 사용하는 변수, 악취다.
- break, continue,
- return 문을 하나로 유지하는 사람이 심기도한다.

### 절차

- 제어 플래그를 사용하는 코드를 함수로 추출할지 고려한다
- 제어플래글르 갱신하는 코드 각각을 적절한 제어문으로 바꾼다. 하나 바꿀때마다 테스트한다. return break continue
- 모두 수정했다면 제어플래그를 제거한다