# Chapter3. 코드에서 나는 악취  
---
'적용 방법을 아는 것'과 '제때 적용'할 줄 아는 것은 다르다.


- 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동원리를 아는 것 못지않게 중요하다.

- 인스턴스 변수를 삭제하거나 상속 계층을 만드는 방법을 설명하기는 쉽다. 
하지만 이런 일들을 '언제'해야하는지에 대해서는 명확하게 정립된 규칙이 없다.

이에 대해서 좀 더 구체적으로 정리해볼 필요가 있다.

그리고 리팩터링이 확실히 필요한 코드들에는 일정한 패턴(냄새)이 있다는 사실을 발견했다.
**냄새나는 코드들의 대표적인 유형 대해 알아봅시다.**

<br/>

### 3.1 기이한 이름

함수든, 변수든, 클래스든 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경써서 지어야한다.

- 이름만 잘 지어도 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있습니다.
- 만약 마땅한 이름이 떠오르지 않는다면 설게에 더 근본적인 문제가 숨어 있을 가능성이 높다.
    
    → 혼한스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.


ex) 어떤 클래스 내에서만 사용되는 USD포매팅 역할의 private함수라면, 꼭 formatAsUSD()가 아니라 그냥 usd()정도로 네이밍(챕터1)

<br/>

### 3.2 중복 코드

- 함수 추출하기 : 양쪽 모두 추출된 메서드를 호출하게 바꾸기
- 문장 슬라이드 : 비슷한 부분을 한곳에 모아 함수 추출하기를 더 쉽게 적용
- 메서드 올리기 : 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 메서드 올리기를 적용해 부모로 올린다.

<br/>

### 3.3 긴 함수

- 경험적으로, 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성된 프로그램입니다.
- 짧은 함수로 구성된 코드베이스를 흝으면 연산하는 부분이 없고, 다 함수 호출(위임) 하는 식으로만 진행되는 것 처럼 보인다.(연산은 말단에서 수행하니까)
- 저자는 이러한 짧은 함수 간접 호출로 구성된 프로그램이 좋은 프로그램이라고 생각함

언제 함수를 분리해야 하는가?
의도를 한눈에 알아볼 수 있는 코드인지 드러나지 않을 때
주석을 달아야만 하는 경우가 좋은 시그널입니다.

**의도는 이름에, 동작 방식은 코드에 드러나도록!**

<br/>


### 3.4 긴 매개변수 목록

요즘에는 매개변수 목록이 길어지면 그 자체로 이해가 어려울 경우가 많다.

매개변수를 줄이는 방법은 다양합니다.

- 매개변수를 질의 함수로 바꾸기
    - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드 :객체 통째로 넘기기
    - 항상 함께 전달되는 매개변수들 : 매개변수 객체 만들기
    - 함수의 동작 방식을 정하는 플래그역할의 매개변수: 플래그 인수 제거하긴
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 : 여러 함수를 클래스로 묶기를 사용하여 공통 값들을 클래스의 필드로 정의
    
    
<br/>



### 3.5 전역 데이터

전역 데이터는 코드베이스 어디에서든 접근할 수 있고 값을 바꿨을 때 누가 바꿧는지 찾아낼 매커니즘이 없다는 게 문제입니다.

그래서 버그가 발생해도 문제의 원인이 되는 코드를 찾아내기가 굉장히 어렵다.

전역 데이터의 대표적인 형태는 전역 변수이지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

- 변수 캡슐화하기
    - 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.
        
        함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
     
<br/>

   

### 3.6 가변 데이터

- 불시에 변경될 수 있고 변경의 추적이 어렵다. 전역 데이터와 같은 맥락입니다.

1. 무분별한 데이터 수정에 따른 사이드 이펙트 발생 위험이 높아질 때
2. 구조체의 내부 필드에 변수가 있는 경우

캡슐화를 통해 변수 수정에 대해 삼시를 수월하게 하기
변수를 갱신하는 코드들의 유효범위를 제한한다.

**결국 데이터의 변경을 인지하고 제어가능할 수 있어야 한다**

<br>

### 3.7 뒤엉킨 변경

- 단일 책임 원칙(SRP)가 제대로 지켜지지 않을 때 나타난다.

→ 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생!

ex) 하나의 모듈이 기능 A,B에 대해 변경이 있을 경우

처리과정의 맥락별로 모듈을 쪼갭시다.

<br/>


### 3.8 산탄총 수술

뒤엉킨 변경과 비슷하면서도 정반대의 개념입니다.

산탄총 수술은 코드를 변경(1)할 때마다 자잘하게 수정해야 하는 클래스(n)가 많을 때 냄새가 납니다.

ex) 하나의 기능 A를 담당하는 부분이 코드베이스 전반에 퍼져 있다고 할 수 있음

함수 옮기기와 필드 옮기기 등 으로 한 모듈에 묶어두어 해결 할 수 있습니다.


<br/>

### 3.9 기능 편애

기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많은 때 풍기는 냄새입니다.


- 해당 함수를 데이터 근처로 함수 옮기기
- 함수의 일부 부분만 편애할 경우 해당 부분만 독립 함수로 함수 추출하기

중요한건 함께 변경할 대상을 한데 모으는 것이다.

<br/>


### 3.10 데이터 뭉치

데이터 항목 서너개가 여러 곳에서 항상 함께 뭉쳐 다닌다면, 데이터 클래스로 묶어줘야 한다.

추후 데이터 클래스에 로직이 붙으면 유용한 클래스가 탄생하는 결과로 이어지기도 합니다.

<br/>


### 3.11 기본형 집착

대부분의 프로그래밍 언어는 다양한 기본 자료형을 제공한다.

화폐, 좌표, 구간 등의 기초타입이 필요하다면 직업 정의해서 사용하도록 하자

<br/>


### 3.12 반복되는 switch문

switch문은 모조리 조건부 로직을 다형성으로 바꾸기로 없애야 할 대상은 아니다.

중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.

위의 이유에 해당하는 switch문은 다형성을 사용하여 최신 스타일의 코드베이스로 바꿔주도록 하자!

<br/>


### 3.13 반복문

일급함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용하여 반복문 사용을 지양하도록하자.

filter or map과 같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지도 쉽게 파악할 수 있다.

하지만 어디든 예외는 있으니 파이프라인 연산이 필요한지 아닌지 판단할 수 있는 능력을 갖추자

<br/>


### 3.14 성의 없는 요소

- 의미 없는 한줄짜리 함수, 메서드가 하나 뿐인 클래스 등이 해당한다.
- 함수 인라인하기, 클래스 인라인하기로 제거하도록하자.

의미가 있느냐 없느냐가 제거 판단의 기준이 됩니다.