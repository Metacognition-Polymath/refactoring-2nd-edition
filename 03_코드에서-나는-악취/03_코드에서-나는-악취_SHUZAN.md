- 리팩토링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링 작동 원리를 아는 것 못지않게 중요하다.
  → 숙련된 사람의 직관 만큼 정확한 기준은 없지만, 특정 징후는 존재한다.

## 3.1 기이한 이름

---

'**이름**' 은 코드를 명료하게 표현하는 가장 중요한 요소 중 하나이다.

> **이름 리팩토링 방법**
>
> 1. 함수 선언바꾸기 - 6.5장
> 2. 변수 이름 바꾸기 - 6.7장
> 3. 필드 이름 바꾸기 - 9.2장

— 만약 마땅한 이름이 떠오르지 않는다면 설계에 근본적이 문제가 있을 가능성이 높다.

→혼란스러운 이름을 정리하면 코드가 훨씬 간결해진다.

## 3.2 중복 코드

---

코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.

→ 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

> **중복 코드 리팩토링**
>
> - **함수 추출하기**
>   — 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
> - **문장 슬라이드하기**
>   — 코드가 비슷하지만, 똑같지 않은 경우
> - **메서드 올리기**
>   — 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어있는 경우

## 3.3 긴 함수

---

- **오랜 기간 잘 활용되는 프로그램은 짧은 함수로 구성됐다.**
  → 끝없이 위임하는 방식으로 작성
  → 간접호출의 효과 — 코드를 이해, 공유, 선택하기 쉬워진다.
- **과거에는 서브루틴 비용때문에 짧은 함수를 꺼렸으나, 최근에는 함수 호출 비용이 거의 사라졌다.**
- **짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 좋은 방법은 좋은 이름이다.**

- **적극적으로 함수를 쪼개는 것이 중요하다.**
  - 주석으로 달 부분은 무조건 함수로 만든다.
  - 동작 방식이 아닌 의도( intention ) 이 들어나도록 짓는다.
  - 원래 코드보다 길어지더라도 함수로 뽑는다. — 함수의 목적이 드러나야 함.
    ⇒ 함수의 길이가 아닌 의도에 목적을 두어야 한다.

— 매개 변수와 임시 변수가 많으면 추출 작업에 방해가 된다.

> **변수 추출**
>
> - 임시변수 질의 함수로 바꾸기 — 임시 변수 감소
> - 매개변수 객체 만들기, 객체 통째로 넘기기 — 매개변수 감소
> - 함수를 명령으로 바꾸기 — 임시, 매개 변수 감소

> -**조건문과 반복문 추출**
>
> - 조건문 분해하기
> - case문마다 함수 추출하기
> - 조건문을 다형성으로 바꾸기
> - 반복문 쪼개기

## 3.4 긴 매개 변수 목록

---

매개 변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.

이런 경우, 다음의 방식을 사용하여 리팩토링 할 수 있다.

1. **매개 변수를 질의 함수로 바꾸기**

   → 다른 매개 변수에서 값을 얻어오는 것 방지

2. **객체 통째로 넘기기**

   → 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달

3. **매개변수 객체 만들기**

   → 원본 데이터 그대로 전달

4. **플래그 인수 제거하기**

   → 함수 동작 방식을 정하는 플래그 역할

5. **여러 함수를 클래스로 묶기**

   → 공통 값들을 클래스 필드로 정의한다. 매개 변수를 효과적으로 줄일 수 있다.

   → 함수형 프로그래밍이라면 부분 적용 함수들을 생성한는 것이라고 볼 수 있다.

## 3.5 전역 데이터

---

‼️ **전역 데이터는 악취 중에서도 지독한 축에 속한다.**

→ 코드베이스 어디에서든 건드릴 수 있고, 누가 바꿧는지 찾아낼 메커니즘이 없다!!

→ 유형처럼 버그는 끊임없이 발생하는데 원인을 찾기 어렵다.

→ 가변데이터의 경우 더욱 까다롭다.

⇒ **변수 캡슐화하기를 통해 리팩토링 할 수 있다.**

> **변수 캡슐화하기**
>
> 함수를 감싸는 것만으로 데이터 수정하는 부분을 쉽게 잡을 수 있다.

## 3.6 가변 데이터

---

- 함수형 프로그래밍에서 데이터는 절대 변하지 않는다.

  → 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

  → 하지만, 함수형 언어가 프로그래밍에서 사용되는 경우가 적고 변수 값을 바꾸루 수 있는 언어를 사용하는 프로그래머가 더 많다.

  ⇒ 리팩토링 방안으로 해결하자.

- 정해놓은 함수를 거쳐야만 값을 수정하도록하면 값의 감시와 코드 개선이 수월하다
  - **변수 캡슐화하기**
- 하나의 변수에 용도가 다른 값을 저장하거나 갱신하여, 용도별 독립 변수에 저장한다.
  - **문장 슬라이드하기**
  - **함수 추출하기**
- 꼭 필요한 경우가 아니면 부작용이 있는 코드를 호출 할 수 없게 한다.
  - **질의 함수와 변경 함수 분리하기**
- 세터를 호출하는 클라이언트를 줄여 유효범위를 줄인다.
  - **세터 제거하기**

## 3.7 뒤엉킨 변경

---

소프트웨어는 구조를 변경하기 쉬운 형태로 조직한다.

소프트웨어는 자고로 소프트해야 마땅하기 때문이다 . 👍

> **뒤엉킨 변경**
>
> — 단일 책임 원칙이 지켜지지 않을 때 나타난다.
>
> — 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때, 발생한다.
>
> **→ 맥락별로 독립된 모듈로 분리해야 프로그래밍 편하다.**

- 순차적으로 실행되는 것이 자연스러운 맥락이라면?
  **⇒ 단계쪼개기**
- 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 진행한다.
  **⇒ 함수 옮기기**
- 여러 맥락에 참여하고 있는 함수가 있다. 각 맥락에 해당하는 적당한 모듈을 만들어서 관련 함수들을 모은다.
  **⇒ 함수 추출하기**

## 3.8 산탄권 수술

---

코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을때 풍긴다.

- 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고, 수정할 곳을 지나치기 쉽다.

  **⇒ 함수 옮기기, 필드 옮기기**

  — 모두 한 모듈에 묶어두면 좋다.

- 비슷한 데이터를 다루는 함수가 많다.

  **⇒ 여러 함수를 클래스에 묶기**

- 데이터 구조를 변환하거나 보강하는 함수

  **⇒ 여러 함수를 변환 함수로 묶기**

- 어설프게 분리된 로직
  **⇒ 함수 인라인하기, 클래스 인라인하기**

이와 같은 경우, 메서드나 클래스는 비대해지지만 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리 할 수 있다.

## 3.9 기능 편애

---

프로그램을 모듈화 할 때

1. 코드는 여러 영역으로 나눈다.
2. 영역안에서 이뤄지는 상호작용을 최대한 늘린다.
3. 영역 사이에서 이뤄지는 상호작용을 최소화한다.

**기능 편애란?**

— 어떤 함수가 자신이 속한 모듈보다 다른 함수나 데이터와 상호작용이 더 많을 때 풍기는 냄새이다.

- 외부 객체의 게터 메서드를 대여섯개 호출하도록 작성한 함수
  **⇒ 함수 옮기기 (8.1장)**
- 함수 일부에서만 기능을 편애
  **⇒ 함수 추출 (6.1장), 함수 옮기기 (8.1장)**
- 어디로 옮길지가 명확하지 않은 경우
  **⇒ 가장 많은 데이터를 포함한 모듈 or 함수를 나눈 후, 적합한 모듈**

## 3.10 데이터 뭉치

---

몰려다니는 데이터들을 보금자리를 마련해주어야 한다.☺️

**데이터의 보금자리 만드는 방법**

1. 필드형태의 데이터 뭉치를 찾아서 하나의 객체로 묶는다. — 클래스 추출하기 (7.5장)
2. 매개 변수를 줄인다 — 매개변수 객체 만들기(6.8장), 객체 통째로 넘기기(11.4장)

- 데이터 뭉치 여부를 판단하는 방법?
  — 값 하나를 삭제해 본다.
  → 나머지 데이터만으로 의미가 없다면, 객체가 되고자 하는 데이터 뭉치이다!

## 3.11 기본형 집착

---

주로 문자열을 다루는 코드에서 많이 나타난다.

- 기본형이 거주하는 자료형 변환
  **→ 기본형을 객체로 바꾸기(7.3장)**
- 기본형으로 표현된 코드가 조건부 동작을 제어한다.
  **→ 타입코드를 서브클래스로 바꾸기(12.6장)**
  **→ 조건부 로직을 다형성으로 바꾸기 (10.4장)**

## 3.12 반복되는 switch문

---

- switch
  — 조건부 로직을 다형성으로 바꾸기로 없애야 할 대상이라는 주장이 존재한다.

→ 현재는 분기 조건에 다양하고 복잡한 타입을 지원하고, 다형성이 널리 자리 잡아서 이전 만큼 악취가 심하지 않다.

## 3.13 반복문

---

프로그래밍 언어가 등장할 때부터 함께 한 핵심요소이다.

하지만, 일급함수를 지원하는 언어가 많아졌다.

**⇒ 반복문을 파이프라인으로 바꾸기를 적용하여 반복문을 제거 할 수 있다.**

## 3.14 성의없는요소

---

본문 코드를 그대로 쓰는 것과 같은 진배없는 함수, 메서드나 하나인 클래스

즉, 성의 없는 요소는 리팩토링하는 것이 좋다.

**⇒ 함수 인라인(8.장) , 클래스 인라인하기 (7.6장) , 계층합치기(12.9장)**

## 3.15 추측의 일반화

---

**추측의 일반화란?**

- 당장은 필요없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 케이스
- 관리하기 어려워진다
- 실제로 사용하면 좋지만, 그렇지 않다면 낭비이다.

  **⇒ 하는 일이 없는 추상 클래스는 계층합치기(12.9장)으로 제거한다.**

  **⇒ 불필요한 위임은 함수인라인, 클래스 인라인으로 삭제한다.**

  **⇒ 필요할거라는 생각에 추가했지만, 사용한적없는 매개변수 삭제한다.**

- 즉, 추측성 일반화는 테스트코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 본다.
  **⇒ 테스트 케이스 삭제 후, 죽은 코드 제거하기로 날리자**

## 3.16 임시필드

---

특정 상황에서만 값이 설정되는 필드를 가지는 클래스도 있다.

→ 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다

→ 덩그러니 떨어진 필드는 모여 살 곳을 찾아주어야 한다.

- 임시 필드와 관련된 코드를 모두 새 클래스에 몰아 넣기
  **⇒ 클래스 추출하기(7.5장) / 함수 옮기기(8.1장)**
- 임시 필드들이 유효한지 확인 후, 동작하는 조건 로직이 있는 경우
  **⇒ 특이케이스 추가하기(1.5장)로 대체 클래스를 만든다.**

## 3.17 메시지 체인

---

메시지 체인은 한 객체를 통해 다른 객체를 얻은 뒤 다른 객체에 요청하는 식이다. 작업이 연쇄적으로 이루어지는 코드를 말한다.

→ 클라이언트가 **객체 내비게이션에 구조**에 종속됐음.

→ 중간 단계를 수정하면 클라이언트 코드도 수정해야한다.

- 중간 객체가 중개자가 되는 경우, 최종 결과 객체를 어떻게 쓰는지 살펴본다.
  **⇒ 위임숨기기**
- 코드 일부를 따로 빼내내 다음 **함수 옮기기**로 체인을 숨길 수 있는지 살펴봐야 한다

```jsx
let managerName = aPerson.department.manager.name;
//관리자 객체를 숨김
managerName = aPerson.department.manager.name;
//부서 객체를 숨김
managerName = aPerson.managerName;
//부서 객체와 관리자 객체 모두의 존재를 숨김
```

```jsx
managerName = aPerson.department.manager.name;
report = `${managerName}께 ${aPerson.name}의 작업로그`;
//=> 생성 로직을 함수로 추출하여 적당한 모듈로 옮기면 체인의 존재가 감춰진다.
```

## 3.18 중개자

---

- **캡슐화**

  - 객체의 대표적인 기능
  - 외부로부터 세부사항을 숨겨주는 역할을 수행한다.
  - 위임이 자주 활용된다.

- 실제로 일을 하는 객체와 직접 소통하게 하자.

  **⇒ 중개자 제거하기**

- 위임 메서드를 제거 후, 호출하는 쪽으로 인라인한다.
  **⇒ 함수 인라인하기**

## 3.19 내부자 거래

---

- 모듈 사이에 거래가 많으면 결합도가 높아진다.

  - 사적으로 처리하는 부분을 줄여야 한다.

  ⇒ **함수 옮기기**와 **필드 옮기기**

- 부모 자식 사이에 결탁이 생길 때가 있다.
  **→ 서브클래스를 위임으로 바꾸기**
  **→ 슈퍼클래스를 위임으로 바꾸기**

## 3.20 거대한 클래스

---

- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다.

- 필드가 너무 많으면 중복 코드가 생기기 쉽다.
  **⇒ 클래스 추출하기 (7.5장)** 으로 필드를 따로 묶는다.
- 분리할 컴포넌트를 원래 클래스와 상속관계로 만들어야 한다면?
  ⇒ **슈퍼클래스 추출하기** 혹은 **타입 코드를 서브클래스**로 바꾸기
  — 클래스 안에서 자체적으로 중복을 제거한다.
- 기능 그룹이 개별 클래스로 추출될 후보다 유용한 기능 그룹을 찾았다면?
  **⇒ 클래스 추출하기, 슈퍼 클래스 추출하기, 타입 코드를 서브클래스로 바꾸기**

## 3.21 서로 다른 인터페이스의 대안 클래스들

---

- **클래스 사용의 장점**
  → 다른 클래스로 교체 할 수 있다.
  → 단, 인터페이스가 같아야한다.
  ⇒ **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다.
  ⇒ **함수 옮기기**를 이용하여 필요한 동작들을 클래스 안으로 밀어 넣는다.
  ⇒ 중복 코드 발생시 **슈퍼 클래스 추출하기**를 적용할지 고려한다.

## 3.22 데이터 클래스

---

- 데이터 클래스?

  — 데이터 필드와 게터, 세터로만 구성된 클래스이다.

  — 단순한 데이터 저장 용도

  — 다른 클래스를 깊이까지 함부로 다루는 경우가 발생한다.

  → public 필드를 레코드 캡슐화한다.

  → 변경하면 안되는 필드는 세터 제거하기로 접근을 봉쇄한다.

- 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하느 메서드를 찾아서 **함수 옮기기**
  ⇒ 옮길 수 있는 부분만 별도 메서드로 뽑는다.
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의되어 있는 신호일 수 있다.
  → 클라이언트 코드를 데이터 클래스로만 옮겨도 대폭 개선된다,
  — 단계쪼개기로 중간데이터 구조를 만드는 경우, 중간데이터는 불변객체이다.
  — 불편 필드는 캡슐할 필요가 없고, 필드 자체를 공개해도 된다.

## 3.23 상속포기

---

모든 클래스 상속이 아니라, 부분만 상속 받고 싶은 경우 주로 사용된다.

**→ 물려받지 않을 부모 코드를 서브클래스로 넘긴다.** (부모에 공통부분만 남기기)

서브클래스가 부모의 동작은 필요하지만, 인터페이스를 따르고 싶지 않은 경우 주로 발생한다.

→ 인터페이스를 따르지 않는다는 것은 상당히 무례한 태도이다.

⇒ **서브클래스 위임으로 바꾸기, 슈퍼클래스 위임으로 바꾸기**

## 3.25 주석

---

- 주석이 장황하게 달린 경우, 코드가 잘못 작성 한 경우가 많다.
- 특정 코드 블록이 하는 일에 주석
  ⇒ 함수 추출하기
- 함수임에도 설명이 필요하다.
  ⇒ 함수 선언 바꾸기
- 선행 조건을 명시하고 싶다.
  ⇒ 어서션 추가하기

> 주석을 남겨야겠다는 생각이 들면, 주석이 필요없는 코드로 리팩터링해본다.

**주석을 사용하면 좋은 경우**

1. 뭘 할지 모를 때
2. 확실하지 않은 부분에 대한 설명
3.
