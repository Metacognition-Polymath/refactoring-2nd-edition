# 01. 리팩터링: 첫 번째 예시

- 원칙이 아닌 예시가 바로 나오는 이유
  - 원칙은 일반화되기 쉬워서 실제 적용방법을 파악하기 어렵지만
  - 예시가 있으면 모든게 명확해지기 때문
- 1장에서 예시를 보면서 리팩터링에 대한 감을 잡고
- 2장 부턴 원칙들을 하나씩 소개
- 책의 예시는 작은 규모이지만 대규모 시스템의 일부라고 상상하면서 따라올 것

## 1.1 자, 시작해보자!

- 초판 : 비디오 대여점에서 영수증을 출력하는 프로그램
- 2판 : 기본틀 유지하되 시대에 맞게 각색

### 상황 설정

- 다양한 연극을 외주로 받아서 공연하는 극단
- 공연 요청 = (연극의 장르, 관객 규모) => 비용 책정
- 이 극단의 두 가지 장르 : 비극, 희극
- 공연료와 별개로 포인트를 지급해서 다음번 의뢰시 공연료 할인 받을 수 있음

### 공연할 연극 정보

```json
// play.json
{
  "hamlet": { "name": "Hamlet", "type": "tragedy" },
  "asLike": { "name": "As You Like It", "type": "comedy" },
  "othello": { "name": "Othello", "type": "tragedy" }
}
```

### 공연료 청구서에 들어갈 데이터

```json
// invoices.json
[
  {
    "customer": "BigCo",
    "performances": [
      {
        "playID": "hamlet",
        "audience": 55
      },
      {
        "playID": "asLike",
        "audience": 35
      },
      {
        "playID": "othello",
        "audience": 40
      }
    ]
  }
]
```

### 공연료 청구서를 출력하는 코드(함수)

- statement.ts 의 1.1

#### new Inl.NumberFormat

- 숫자를 지정한 나라의 통화 형태로 포맷을 변환시켜 출력하는 것
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat

#### Math.max()

max()에 전달함 params 들 중에서 최대값을 출력

## 1.2 예시 프로그램을 본 소감

- 수백 줄짜리 코드를 수정할 때

  - 코드를 여러함수와 프로그램 요소로 재구성
    - 프로그램 작동방식을 더 쉽게 파악하기 위해
    - 프로그램 구조가 빈약하다면 => 구조부터 잡은 뒤 기능을 수정

- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면
  - 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 원하는 기능을 추가

### 이 프로그램에서 수정할 부분

- 청구 내역을 HTML로 출력하는 기능이 필요하다면?
- 위 statement()는 기능 추가에 유연하지 못 하다.
  - 리팩터링 필요

## 1.3 리팩터링의 첫 단계

- 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드 부터 마련
  - 리팩터링한 코드가 예상치 못한 문제가 발생하는 것으로 부터 보호
- 테스트
  - 미리 입력값에 대한 결과값을 예상 후 실제로 그것과 일치하는 지 확인
  - 테스트 결과는 알아보기 쉽게 성공/실패에 따라 초록/빨강으로 표시

#### 리팩터링하기 전에 제대로 된 테스트 부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.

## 1.4 statement() 함수 쪼개기

- statement() 처럼 긴 함수를 리팩터링할 때
  - 전체 동작을 각각의 부분으로 나눌 지점을 찾음
    - 1.1의 statement()에선 switch문

### 관련 코드

- statement_1-4.ts

- 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다.
  - 그래서 중간에 실수 하더라도 버그를 쉽게 찾을 수 있다.
- 리팩터링 후 항상 테스트하는 습관을 들이자
- 하나의 리팩터링을 문제없이 끝낼 때 마다 커밋한다.

#### switch문 분리

- amountFor() 함수로 분리

#### 변수명 명확하게 변경

- thisAmount -> result
- perf -> aPerformance

#### play 변수 제거

```typescript
const play = playFor(plays, perf); // 이건 굳이 함수로 만들어야 되나? plays[perf.playID];
function playFor(plays: Plays, aPerformance: Performance) {
  // 책엔 plays를 받지 않지만 typescript에선 받지 않으면 에러이므로 parameter를 추가 함
  return plays[aPerformance.playID];
}
```
