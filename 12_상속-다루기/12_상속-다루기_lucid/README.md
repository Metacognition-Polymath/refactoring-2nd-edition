# 상속 다루기
## 12.1 메서드 올리기

### 배경 
 - 중복 코드 제거는 중요하다.
 - 하지만 테스트를 잘해야한다. 
 - 서도 다른 두 클래스의 두 메서를 가각 매게변수화하면 궁극적으로 같은 메소드가 된다
 - 복잡한 상황: 해당 메서드의 본문에서 참조하는 필드들이 서브클래ㅔ스에서만 있은 경우
   - 필드를 먼저 슈퍼 클래스에 올린 후 메서드 올리자
 - 두 메서드 비슷하지만 세부 내용이 다르다면 템플릿 메서드를 만들기를 고려해보자

### 절차
 1) 똑같이 동작하는 메서드인지 면밀히 살펴본다
    - 실질적으로 하는 일ㅇ을 같지만 코드가 다르다면 본문 코드가 똑가아 질때까지 리팩터링한다.
 2) 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서 호출하고 참조 할 수 있는지 확인하다
 3) 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다.
 4) 정적 검사를 수행한다.
 5) 서브클래스 중 하나의 메서드를 제거한다.
 6) 테스트한다.
 7) 모든 서브클랫의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다.

## 12.2 필드 올리기

### 배경
 - 서브클래스들이 독립적으로 개발되었거나 => 뒤늦계 계층구조로 리팩터링된 경우라면 일부 기능이 중복되었을 가능성이 왕왕있다
 - 필드 중복이 쉽다. 이름이 비슷하는게 당연하지만 항상그렇지 않다
 - 분석후 비슷할경우 슈퍼클래스로 올리다
 - 장점: 첫째 데이터 중복 선언 없앨수 있다, 둘째 해당 필드 사용 독작을 서브클래스에서 슈퍼 클래스로 옮길 수 있다
 - 주의할점: 동적언어는 필드를 클래스 정의에 포함시키지 않는 경우가 있다. 필드에 가장 처음 값이 대입될때 등장할수도있다(선언안한지 쳐다 보지않은거같음) - 생성자 본문부터 올려야한다

### 순서
 1) 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하지 살펴라
 2) 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다(필드 이름 바꾸기)
 3) 슈퍼클래스에 새로운 필드를 생성한다.
    => 서브클래스에서 이 필드에 접근 할 수 있어야한다. (protected 로 선언하면 된다)
 4) 서브 클래스의 필드들의 제거한다
 5) 테스트한다
 
## 12.3 생성자 본문 올리기

### 배경
 - 생성자는 다루기 까다롭다. 일반 메서드와는 많이 달라서, 생성하는 일을 제약하는 편이다.
 - 서브 클래스 기능 같은 메서드 발견시 함수 추추랗기와 메서드 올리기를 차례로 적용하여 말끔히 슈퍼 클래스로 옮기곤 한다.
 - 하필이면 생성자일겨웅 스텝이 꼬인다.

### 절차
 1) 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인하다
 2) 문장 슬라이드 하기로 공통 문장 모두를 super() 호출 직후로 옮긴다.
 3) 공통 코드를 슈퍼클래에 추가하고 서브클래스들에게 제거한다. 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건낸다.
 4) 테스트한다.
 5) 생성자 시작 부분으로 옮길 수 없는 공통 코드에서 함수 추출하기와 메서드 올리기를 차례로 적용한다.

## 12.4 메서드 내리기

~~~typescript
  class Employee {
    get quota(){ return '인용문'}
  }
  
  class Engineer extends Employee {}
  class Salesperson extends Employee {
    get quota(){
      // ~~~ 어려운 코드
      return '여기서만 쓰니 올리자'
    }
  }
  
~~~
### 배경
 - 특정 하위클래스에서만 있다면 서브 클래스로 올기는게 낫다.
 - 호출하는게 정확히 알때 적용한다.
 - 만약 정확히 모르면 기만적인 조건부 로직을 다형성으로 바꿔야한다.
 - 
                          
## 12.5 필드 내리기
### 배경
 - 서브클래스 하나에서만 사용하는 필드는 해당 서브클래스들로 옮긴다
### 절차
 - 대상 필드를 모든 서브클래스에 정의한다.
 - 슈퍼클래스에서 그 필드를 제거한다.   
 - 테스트 한다.
 - 이 필드를 사용하지 않는 모든 서브크랠르셍서 제거한다.
 - 테스트한다.
           
                      
## 12.6 타입 코드를 서브클래스로 바꾸기

### 배경
 - 배경소프트웨어 시스템에서 비슷한 대상들을 특정 특성에 따라 구분해야 할때가 자주 있다. 
 - 담당 업무로 구분,시급성 구분, 이럴때 타입코드 필드, 열거형, 심볼 문자열, 타입코드 필드가 있다.
 - 그 이상일 경우 서브클래스를 가르킨다. 조건에 따라 다르게 동작하는 다형성 서브클레스를 만든다
    1) 조건에 따라 다르게 동자갛도록 해주는 다형성 제공한다. 타입 코드에 따라 동작이 달라져야 함수가 여러개 일때 유용하다.
    2) 특정 타입에서만 의미 있는  값을 사용하는 필드나 메서드가 있을때 발현된다.
        - 판매 목표 => 영업자 유형일때 의미 있음. 필요한 서클래스 필드만 갖도록 정리하자
 - 리팩터링은 대상 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 한다.

### 절차
 1) 타입 코드 필드를 자가 캡슐화 한다.
 2) 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브 클래스를 만든다. 타입 코드 게터 메서드를 오버 라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다.
 3) 매개변수로 받은 타입 코드의 리터럴 값을 반환하게한다.
 4) 매게변수로 받은 타입 코드와 방금 만든 서브클래스를 매팡하는 선택로직을 만든다.
 5) 테스트한다.
 6) 타입 코드 값 각각에 서브클래스 생성과 선택 로직 추가를 반복한다. 클래스 하나가 완성될때마다 테스트 한다.
 7) 타입 코드 필드를 제거한다.
 8) 테스트한다.
 9) 타입 코드 접근자를 이요하는 메서드 모두에 메서드 내리 와 조건부로직을 다형성으로 바꾸기를 적용한다.
 
## 12.7 서브 클래스 제거하기

### 배경
 - 서브 클래스는 원래 데이터 구조아는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 잇는 유용한 메커니즘이다.
 - 다름을 프로그래밍하는 멋진 수단인 것이다.
 - 에너지낭비하지말고 서브클래스를 슈퍼클래스의 필드로 대체해 제거하는게 최선일경우가있다.

### 절차
 1) 서브클래스의 생성자를 팩터리 함수로 바꾼다.
 2) 서브 클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼클래스로 옮긴다. 허나 변경할때마다 테스트한다.
 3) 서브클래스의 타입을 나타내드는 필드를 슈퍼클래스에 만든다.
 4) 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하다록 수정한다.
 5) 서브클래스를 지운다.
 6) 테스트한다.

## 12.8 슈퍼클래스 추출하기

### 배경
 - 비슷한 일을 수행하는 두 클래스가 있을경우 슈퍼 클래스로 만들수있다.
 - 공통된 부분 => 필드올리기, 동작 => 메서드 올리기
 - 완벽한 이해로 한다고하지만 => 독자는 상속은 프로그램이 성장 하면서깨치고, 슈퍼클래스 공통요소를 찾앗을때가 더 많았다고함
 - 대안으로는 클래스 추출하기(위임)
 - 슈퍼 클래스를 더 우선시 해라(왜 더 쉬우니까)

### 절차
 1) 빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록 한다.
    - 필요하다면 생성자에 함수 선언 바꾸기를 적용한다.
 2) 테스트한다.
 3) 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 차례로 적용하여 공통 원소를 슈퍼클래스로 옮긴다
 4) 서브클래스에 남은 메서들을 검토한다. 공통되는 부분이 있다면 함수로 추출한 다음 메서드 올리기를 적용한다
 5) 원래 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다.

## 12.9 계층 합치기

### 배경
 - 쪼개거나 나누거나, 너무 비슷해질때 하치자

### 절차
 - 두 클래스 중 제거할 것을 고른다
 - 필드 올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 저굥하여 모든 요소를 하나의 클래스로 옮긴다.
 - 제거할 크랠스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다.
 - 빈 클래스를 제거한다.
 - 테스트 한다.
          

## 12.11 슈퍼클래스 위임으로 바꾸기

### 배경
 - 객체지향 프로그래밍에서 상속 기존 기능 재활용 하는 강력하고 손쉬운 수단이다.
 - 자바 스택문제: 너무 스택에 쌓아서 기능이 많다.
 - 자동차 모델클래스 + 식별번호 제조일자 = 자동차를 표현 한다느 착각(아직 많이 모자름)
 - 위임은 기능 일부만 빌려올뿌느 서로 별개의 기능으로 정확히 알수 있다는거싱다.
 - 위임의 단점: 호스트의 함수 모두를 전달함수로 만들어ㅑ한다.(지루하다. 하지만 문제는 없을 것이다)

### 절차
 1) 슈퍼클래스 객체를 참조하는 필드를 서브클래스로 만든다.(위임참조라 하자) 위임 참조를 새로운 슈퍼 클래스 인스턴스로 초기화한다.
 2) 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다. 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트한다.
 3) 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드되었다면 상속 관계를 끊는다.
